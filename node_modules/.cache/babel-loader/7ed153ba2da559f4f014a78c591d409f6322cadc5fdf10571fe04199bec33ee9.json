{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\nconst command_1 = require(\"./command\");\nconst common_functions_1 = require(\"./common_functions\");\nconst write_concern_1 = require(\"../write_concern\");\nconst bulk_write_1 = require(\"./bulk_write\");\n/** @internal */\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    var _a;\n    super(undefined, options);\n    this.options = {\n      ...options,\n      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false\n    };\n    this.ns = ns;\n    this.documents = documents;\n  }\n  execute(server, session, callback) {\n    var _a;\n    const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    if (typeof options.comment !== 'undefined') {\n      command.comment = options.comment;\n    }\n    super.executeCommand(server, session, command, callback);\n  }\n}\nexports.InsertOperation = InsertOperation;\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, common_functions_1.prepareDocs(collection, [doc], options), options);\n  }\n  execute(server, session, callback) {\n    super.execute(server, session, (err, res) => {\n      var _a, _b;\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new error_1.MongoServerError(res));\n      if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));\n      callback(undefined, {\n        acknowledged: (_b = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n}\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoDriverError('docs parameter must be an array of documents');\n    }\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = {\n      ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference\n    };\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, common_functions_1.prepareDocs(coll, this.docs, options).map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      var _a;\n      if (err || res == null) return callback(err);\n      callback(undefined, {\n        acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n}\nexports.InsertManyOperation = InsertManyOperation;\noperation_1.defineAspects(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"names":["error_1","require","operation_1","command_1","common_functions_1","write_concern_1","bulk_write_1","InsertOperation","CommandOperation","constructor","ns","documents","options","undefined","checkKeys","_a","execute","server","session","callback","ordered","command","insert","collection","bypassDocumentValidation","comment","executeCommand","exports","InsertOneOperation","doc","s","namespace","prepareDocs","err","res","code","MongoServerError","writeErrors","acknowledged","_b","writeConcern","w","insertedId","_id","InsertManyOperation","AbstractOperation","docs","Array","isArray","MongoDriverError","coll","bsonOptions","readPreference","WriteConcern","fromOptions","bulkWriteOperation","BulkWriteOperation","map","document","insertOne","insertedCount","insertedIds","defineAspects","Aspect","RETRYABLE","WRITE_OPERATION"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\operations\\insert.ts"],"sourcesContent":["import { MongoDriverError, MongoServerError } from '../error';\nimport { defineAspects, Aspect, AbstractOperation } from './operation';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { prepareDocs } from './common_functions';\nimport type { Callback, MongoDBNamespace } from '../utils';\nimport type { Server } from '../sdam/server';\nimport type { Collection } from '../collection';\nimport type { Document } from '../bson';\nimport type { BulkWriteOptions } from '../bulk/common';\nimport { WriteConcern } from '../write_concern';\nimport type { ClientSession } from '../sessions';\nimport { BulkWriteOperation } from './bulk_write';\nimport type { InferIdType } from '../mongo_types';\n\n/** @internal */\nexport class InsertOperation extends CommandOperation<Document> {\n  options: BulkWriteOptions;\n  documents: Document[];\n\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\n    super(undefined, options);\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<Document>): void {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.comment !== 'undefined') {\n      command.comment = options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n}\n\n/** @public */\nexport interface InsertOneOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\n  bypassDocumentValidation?: boolean;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n}\n\n/** @public */\nexport interface InsertOneResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\n  insertedId: InferIdType<TSchema>;\n}\n\nexport class InsertOneOperation extends InsertOperation {\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\n    super(collection.s.namespace, prepareDocs(collection, [doc], options), options);\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<InsertOneResult>): void {\n    super.execute(server, session, (err, res) => {\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new MongoServerError(res));\n      if (res.writeErrors) return callback(new MongoServerError(res.writeErrors[0]));\n\n      callback(undefined, {\n        acknowledged: this.writeConcern?.w !== 0 ?? true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n}\n\n/** @public */\nexport interface InsertManyResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of inserted documents for this operations */\n  insertedCount: number;\n  /** Map of the index of the inserted document to the id of the inserted document */\n  insertedIds: { [key: number]: InferIdType<TSchema> };\n}\n\n/** @internal */\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\n  options: BulkWriteOptions;\n  collection: Collection;\n  docs: Document[];\n\n  constructor(collection: Collection, docs: Document[], options: BulkWriteOptions) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new MongoDriverError('docs parameter must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<InsertManyResult>): void {\n    const coll = this.collection;\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\n    const writeConcern = WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new BulkWriteOperation(\n      coll,\n      prepareDocs(coll, this.docs, options).map(document => ({ insertOne: { document } })),\n      options\n    );\n\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      if (err || res == null) return callback(err);\n      callback(undefined, {\n        acknowledged: writeConcern?.w !== 0 ?? true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n}\n\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}