{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.commandSupportsReadConcern = exports.ServerSessionPool = exports.ServerSession = exports.ClientSession = void 0;\nconst promise_provider_1 = require(\"./promise_provider\");\nconst bson_1 = require(\"./bson\");\nconst read_preference_1 = require(\"./read_preference\");\nconst transactions_1 = require(\"./transactions\");\nconst common_1 = require(\"./sdam/common\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst read_concern_1 = require(\"./read_concern\");\nconst minWireVersionForShardedTransactions = 8;\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new error_1.MongoDriverError('Cannot use a session that has ended');\n    if (typeof callback === 'function') {\n      callback(error);\n      return false;\n    }\n    throw error;\n  }\n  return true;\n}\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param topology - The current client's topology (Internal Class)\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n    /** @internal */\n    this[_a] = false;\n    if (topology == null) {\n      throw new error_1.MongoDriverError('ClientSession requires a topology');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new error_1.MongoDriverError('ClientSession requires a ServerSessionPool');\n    }\n    options = options !== null && options !== void 0 ? options : {};\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoDriverError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n    this.supports = {\n      causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n  get id() {\n    var _b;\n    return (_b = this.serverSession) === null || _b === void 0 ? void 0 : _b.id;\n  }\n  get serverSession() {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this[kServerSession];\n  }\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return utils_1.maybePromise(callback, done => {\n      if (this.hasEnded) {\n        return done();\n      }\n      const completeEndSession = () => {\n        // release the server session back to the pool\n        this.sessionPool.release(this.serverSession);\n        this[kServerSession] = undefined;\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n        // spec indicates that we should ignore all errors for `endSessions`\n        done();\n      };\n      if (this.serverSession && this.inTransaction()) {\n        this.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n        return;\n      }\n      completeEndSession();\n    });\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /** Increment the transaction number on the internal ServerSession */\n  incrementTransactionNumber() {\n    if (this.serverSession) {\n      this.serverSession.txnNumber = typeof this.serverSession.txnNumber === 'number' ? this.serverSession.txnNumber + 1 : 0;\n    }\n  }\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options) {\n    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoDriverError('Transactions are not allowed with snapshot sessions');\n    }\n    assertAlive(this);\n    if (this.inTransaction()) {\n      throw new error_1.MongoDriverError('Transaction already in progress');\n    }\n    const topologyMaxWireVersion = utils_1.maxWireVersion(this.topology);\n    if (shared_1.isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoDriverError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new transactions_1.Transaction({\n      readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n      writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n      readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n      maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n  commitTransaction(callback) {\n    return utils_1.maybePromise(callback, cb => endTransaction(this, 'commitTransaction', cb));\n  }\n  abortTransaction(callback) {\n    return utils_1.maybePromise(callback, cb => endTransaction(this, 'abortTransaction', cb));\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON() {\n    throw new error_1.MongoDriverError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param fn - A lambda to run within a transaction\n   * @param options - Optional settings for the transaction\n   */\n  withTransaction(fn, options) {\n    const startTime = utils_1.now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction hasNotTimedOut(startTime, max) {\n  return utils_1.calculateDurationInMs(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n    throw err;\n  });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  session.startTransaction(options);\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n  if (!utils_1.isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new error_1.MongoDriverError('Function provided to `withTransaction` must return a Promise');\n  }\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel('UnknownTransactionCommitResult');\n      }\n      throw err;\n    }\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n    return maybeRetryOrThrow(err);\n  });\n}\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  }\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoDriverError('No transaction started'));\n    return;\n  }\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoDriverError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoDriverError('Cannot call abortTransaction twice'));\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoDriverError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n  // construct and send the command\n  const command = {\n    [commandName]: 1\n  };\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n  function commandHandler(e, r) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n    if (e) {\n      if (e instanceof error_1.MongoNetworkError || e instanceof error_1.MongoWriteConcernError || error_1.isRetryableError(e) || isMaxTimeMSExpiredError(e)) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult');\n          // per txns spec, must unpin session in this case\n          session.transaction.unpinServer();\n        }\n      } else if (e.hasErrorLabel('TransientTransactionError')) {\n        session.transaction.unpinServer();\n      }\n    }\n    callback(e, r);\n  }\n  // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n  // send the command\n  execute_operation_1.executeOperation(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary\n  }), (err, reply) => {\n    if (err && error_1.isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.transaction.unpinServer();\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n      return execute_operation_1.executeOperation(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary\n      }), (_err, _reply) => commandHandler(_err, _reply));\n    }\n    commandHandler(err, reply);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary(utils_1.uuidV4(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = utils_1.now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(utils_1.calculateDurationInMs(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new error_1.MongoDriverError('ServerSessionPool requires a topology');\n    }\n    this.topology = topology;\n    this.sessions = [];\n  }\n  /** Ends all sessions in the session pool */\n  endAllPooledSessions(callback) {\n    if (this.sessions.length) {\n      this.topology.endSessions(this.sessions.map(session => session.id), () => {\n        this.sessions = [];\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n      return;\n    }\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n      if (session && !session.hasTimedOut(sessionTimeoutMinutes)) {\n        return session;\n      }\n    }\n    return new ServerSession();\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\nexports.ServerSessionPool = ServerSessionPool;\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n  return false;\n}\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n */\nfunction applySession(session, command, options) {\n  var _b;\n  // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n  if (session.hasEnded) {\n    return new error_1.MongoDriverError('Attempted to use a session that has ended');\n  }\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new error_1.MongoDriverError('Unable to acquire server session');\n  }\n  // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  // FIXME: NODE-2781, this check for write concern shouldn't be happening here, but instead during command construction\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    if (session && session.explicit) {\n      return new error_1.MongoDriverError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = utils_1.now();\n  command.lsid = serverSession.id;\n  // first apply non-transaction-specific sessions data\n  const inTransaction = session.inTransaction() || transactions_1.isTransactionCommand(command);\n  const isRetryableWrite = (options === null || options === void 0 ? void 0 : options.willRetryWrite) || false;\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n  if (!inTransaction) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n    if (session.supports.causalConsistency && session.operationTime && commandSupportsReadConcern(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n      if (session[kSnapshotTime] !== undefined) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n    return;\n  }\n  // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || ((_b = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _b === void 0 ? void 0 : _b.readConcern);\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n  var _b;\n  if (document.$clusterTime) {\n    common_1.resolveClusterTime(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] === undefined) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"names":["promise_provider_1","require","bson_1","read_preference_1","transactions_1","common_1","shared_1","error_1","utils_1","execute_operation_1","run_command_1","mongo_types_1","read_concern_1","minWireVersionForShardedTransactions","assertAlive","session","callback","serverSession","error","MongoDriverError","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","ClientSession","TypedEventEmitter","constructor","topology","sessionPool","options","clientOptions","_a","ServerSessionPool","snapshot","causalConsistency","hasEnded","undefined","supports","clusterTime","initialClusterTime","operationTime","explicit","owner","defaultTransactionOptions","Object","assign","transaction","Transaction","id","_b","acquire","snapshotEnabled","endSession","maybePromise","done","completeEndSession","release","emit","inTransaction","abortTransaction","err","advanceOperationTime","greaterThan","equals","buffer","incrementTransactionNumber","txnNumber","isActive","startTransaction","topologyMaxWireVersion","maxWireVersion","isSharded","readConcern","_c","_d","writeConcern","_f","_e","_g","readPreference","_j","_h","_k","maxCommitTimeMS","_l","transition","TxnState","STARTING_TRANSACTION","commitTransaction","cb","endTransaction","toBSON","withTransaction","fn","startTime","now","attemptTransaction","exports","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","calculateDurationInMs","isUnknownTransactionCommitResult","isNonDeterministicWriteConcernError","MongoServerError","codeName","has","isMaxTimeMSExpiredError","code","MONGODB_ERROR_CODES","UnsatisfiableWriteConcern","UnknownReplWriteConcern","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","catch","MongoError","hasErrorLabel","USER_EXPLICIT_TXN_END_STATES","NO_TRANSACTION","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","state","Promise","PromiseProvider","get","promise","reject","isPromiseLike","then","maybeRetryOrThrow","addErrorLabel","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","w","wtimeout","maxTimeMS","commandHandler","e","r","MongoNetworkError","MongoWriteConcernError","isRetryableError","unpinServer","recoveryToken","executeOperation","RunAdminCommandOperation","ReadPreference","primary","reply","_err","_reply","ServerSession","Binary","uuidV4","SUBTYPE_UUID","lastUse","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","sessions","endAllPooledSessions","length","endSessions","map","logicalSessionTimeoutMinutes","shift","pooledSession","pop","unshift","commandSupportsReadConcern","aggregate","count","distinct","find","geoNear","mapReduce","out","inline","applySession","lsid","isTransactionCommand","isRetryableWrite","willRetryWrite","Long","fromNumber","afterClusterTime","level","ReadConcernLevel","atClusterTime","autocommit","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","resolveClusterTime","_recoveryToken","cursor"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\sessions.ts"],"sourcesContent":["import { PromiseProvider } from './promise_provider';\nimport { Binary, Long, Timestamp, Document } from './bson';\nimport { ReadPreference } from './read_preference';\nimport { isTransactionCommand, TxnState, Transaction, TransactionOptions } from './transactions';\nimport { resolveClusterTime, ClusterTime } from './sdam/common';\nimport { isSharded } from './cmap/wire_protocol/shared';\nimport {\n  MongoError,\n  isRetryableError,\n  MongoNetworkError,\n  MongoWriteConcernError,\n  MONGODB_ERROR_CODES,\n  MongoDriverError,\n  MongoServerError\n} from './error';\nimport {\n  now,\n  calculateDurationInMs,\n  Callback,\n  isPromiseLike,\n  uuidV4,\n  maxWireVersion,\n  maybePromise\n} from './utils';\nimport type { Topology } from './sdam/topology';\nimport type { MongoOptions } from './mongo_client';\nimport { executeOperation } from './operations/execute_operation';\nimport { RunAdminCommandOperation } from './operations/run_command';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport type { CommandOptions } from './cmap/connection';\nimport type { WriteConcern } from './write_concern';\nimport { TypedEventEmitter } from './mongo_types';\nimport { ReadConcernLevel } from './read_concern';\n\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session: ClientSession, callback?: Callback): boolean {\n  if (session.serverSession == null) {\n    const error = new MongoDriverError('Cannot use a session that has ended');\n    if (typeof callback === 'function') {\n      callback(error);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n\n/** @public */\nexport interface ClientSessionOptions {\n  /** Whether causal consistency should be enabled on this session */\n  causalConsistency?: boolean;\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\n  snapshot?: boolean;\n  /** The default TransactionOptions to use for transactions started on this session. */\n  defaultTransactionOptions?: TransactionOptions;\n\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  /** @internal */\n  explicit?: boolean;\n  /** @internal */\n  initialClusterTime?: ClusterTime;\n}\n\n/** @public */\nexport type WithTransactionCallback<T = void> = (session: ClientSession) => Promise<T>;\n\n/** @public */\nexport type ClientSessionEvents = {\n  ended(session: ClientSession): void;\n};\n\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nexport class ClientSession extends TypedEventEmitter<ClientSessionEvents> {\n  /** @internal */\n  topology: Topology;\n  /** @internal */\n  sessionPool: ServerSessionPool;\n  hasEnded: boolean;\n  clientOptions?: MongoOptions;\n  supports: { causalConsistency: boolean };\n  clusterTime?: ClusterTime;\n  operationTime?: Timestamp;\n  explicit: boolean;\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  defaultTransactionOptions: TransactionOptions;\n  transaction: Transaction;\n  /** @internal */\n  [kServerSession]?: ServerSession;\n  /** @internal */\n  [kSnapshotTime]?: Timestamp;\n  /** @internal */\n  [kSnapshotEnabled] = false;\n\n  /**\n   * Create a client session.\n   * @internal\n   * @param topology - The current client's topology (Internal Class)\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(\n    topology: Topology,\n    sessionPool: ServerSessionPool,\n    options: ClientSessionOptions,\n    clientOptions?: MongoOptions\n  ) {\n    super();\n\n    if (topology == null) {\n      throw new MongoDriverError('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new MongoDriverError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options ?? {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new MongoDriverError(\n          'Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive'\n        );\n      }\n    }\n\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n\n    this.supports = {\n      causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = undefined;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n\n  /** The server id associated with this session */\n  get id(): ServerSessionId | undefined {\n    return this.serverSession?.id;\n  }\n\n  get serverSession(): ServerSession {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this[kServerSession]!;\n  }\n\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled(): boolean {\n    return this[kSnapshotEnabled];\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   * @param callback - Optional callback for completion of this operation\n   */\n  endSession(): Promise<void>;\n  endSession(callback: Callback<void>): void;\n  endSession(options: Record<string, unknown>): Promise<void>;\n  endSession(options: Record<string, unknown>, callback: Callback<void>): void;\n  endSession(\n    options?: Record<string, unknown> | Callback<void>,\n    callback?: Callback<void>\n  ): void | Promise<void> {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return maybePromise(callback, done => {\n      if (this.hasEnded) {\n        return done();\n      }\n\n      const completeEndSession = () => {\n        // release the server session back to the pool\n        this.sessionPool.release(this.serverSession);\n        this[kServerSession] = undefined;\n\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n\n        // spec indicates that we should ignore all errors for `endSessions`\n        done();\n      };\n\n      if (this.serverSession && this.inTransaction()) {\n        this.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime: Timestamp): void {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session: ClientSession): boolean {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n\n  /** Increment the transaction number on the internal ServerSession */\n  incrementTransactionNumber(): void {\n    if (this.serverSession) {\n      this.serverSession.txnNumber =\n        typeof this.serverSession.txnNumber === 'number' ? this.serverSession.txnNumber + 1 : 0;\n    }\n  }\n\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction(): boolean {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options?: TransactionOptions): void {\n    if (this[kSnapshotEnabled]) {\n      throw new MongoDriverError('Transactions are not allowed with snapshot sessions');\n    }\n\n    assertAlive(this);\n    if (this.inTransaction()) {\n      throw new MongoDriverError('Transaction already in progress');\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\n    if (\n      isSharded(this.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoDriverError(\n        'Transactions are not supported on sharded clusters in MongoDB < 4.2.'\n      );\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new Transaction({\n      readConcern:\n        options?.readConcern ??\n        this.defaultTransactionOptions.readConcern ??\n        this.clientOptions?.readConcern,\n      writeConcern:\n        options?.writeConcern ??\n        this.defaultTransactionOptions.writeConcern ??\n        this.clientOptions?.writeConcern,\n      readPreference:\n        options?.readPreference ??\n        this.defaultTransactionOptions.readPreference ??\n        this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  commitTransaction(): Promise<Document>;\n  commitTransaction(callback: Callback<Document>): void;\n  commitTransaction(callback?: Callback<Document>): Promise<Document> | void {\n    return maybePromise(callback, cb => endTransaction(this, 'commitTransaction', cb));\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  abortTransaction(): Promise<Document>;\n  abortTransaction(callback: Callback<Document>): void;\n  abortTransaction(callback?: Callback<Document>): Promise<Document> | void {\n    return maybePromise(callback, cb => endTransaction(this, 'abortTransaction', cb));\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON(): never {\n    throw new MongoDriverError('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param fn - A lambda to run within a transaction\n   * @param options - Optional settings for the transaction\n   */\n  withTransaction<T = void>(\n    fn: WithTransactionCallback<T>,\n    options?: TransactionOptions\n  ): ReturnType<typeof fn> {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction hasNotTimedOut(startTime: number, max: number) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err: MongoError) {\n  const isNonDeterministicWriteConcernError =\n    err instanceof MongoServerError &&\n    err.codeName &&\n    NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!isNonDeterministicWriteConcernError &&\n      err.code !== MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n      err.code !== MONGODB_ERROR_CODES.UnknownReplWriteConcern)\n  );\n}\n\nfunction isMaxTimeMSExpiredError(err: MongoError) {\n  if (err == null || !(err instanceof MongoServerError)) {\n    return false;\n  }\n\n  return (\n    err.code === MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n    (err.writeConcernError && err.writeConcernError.code === MONGODB_ERROR_CODES.MaxTimeMSExpired)\n  );\n}\n\nfunction attemptTransactionCommit<T>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<T>,\n  options?: TransactionOptions\n): Promise<T> {\n  return session.commitTransaction().catch((err: MongoError) => {\n    if (\n      err instanceof MongoError &&\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n      !isMaxTimeMSExpiredError(err)\n    ) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set<TxnState>([\n  TxnState.NO_TRANSACTION,\n  TxnState.TRANSACTION_COMMITTED,\n  TxnState.TRANSACTION_ABORTED\n]);\n\nfunction userExplicitlyEndedTransaction(session: ClientSession) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction<TSchema>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<TSchema>,\n  options?: TransactionOptions\n): Promise<any> {\n  const Promise = PromiseProvider.get();\n  session.startTransaction(options);\n\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new MongoDriverError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(\n    () => {\n      if (userExplicitlyEndedTransaction(session)) {\n        return;\n      }\n\n      return attemptTransactionCommit(session, startTime, fn, options);\n    },\n    err => {\n      function maybeRetryOrThrow(err: MongoError): Promise<any> {\n        if (\n          err instanceof MongoError &&\n          err.hasErrorLabel('TransientTransactionError') &&\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\n        ) {\n          return attemptTransaction(session, startTime, fn, options);\n        }\n\n        if (isMaxTimeMSExpiredError(err)) {\n          err.addErrorLabel('UnknownTransactionCommitResult');\n        }\n\n        throw err;\n      }\n\n      if (session.transaction.isActive) {\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n      }\n\n      return maybeRetryOrThrow(err);\n    }\n  );\n}\n\nfunction endTransaction(session: ClientSession, commandName: string, callback: Callback<Document>) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  }\n\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoDriverError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (\n      txnState === TxnState.STARTING_TRANSACTION ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(\n        new MongoDriverError('Cannot call commitTransaction after calling abortTransaction')\n      );\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoDriverError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (\n      txnState === TxnState.TRANSACTION_COMMITTED ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      callback(\n        new MongoDriverError('Cannot call abortTransaction after calling commitTransaction')\n      );\n      return;\n    }\n  }\n\n  // construct and send the command\n  const command: Document = { [commandName]: 1 };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = { w: session.clientOptions.writeConcern.w };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, { writeConcern });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n  }\n\n  function commandHandler(e?: MongoError, r?: Document) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n\n    session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n    if (e) {\n      if (\n        e instanceof MongoNetworkError ||\n        e instanceof MongoWriteConcernError ||\n        isRetryableError(e) ||\n        isMaxTimeMSExpiredError(e)\n      ) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult');\n\n          // per txns spec, must unpin session in this case\n          session.transaction.unpinServer();\n        }\n      } else if (e.hasErrorLabel('TransientTransactionError')) {\n        session.transaction.unpinServer();\n      }\n    }\n    callback(e, r);\n  }\n\n  // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  // send the command\n  executeOperation(\n    session.topology,\n    new RunAdminCommandOperation(undefined, command, {\n      session,\n      readPreference: ReadPreference.primary\n    }),\n    (err, reply) => {\n      if (err && isRetryableError(err as MongoError)) {\n        // SPEC-1185: apply majority write concern when retrying commitTransaction\n        if (command.commitTransaction) {\n          // per txns spec, must unpin session in this case\n          session.transaction.unpinServer();\n\n          command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n            w: 'majority'\n          });\n        }\n\n        return executeOperation(\n          session.topology,\n          new RunAdminCommandOperation(undefined, command, {\n            session,\n            readPreference: ReadPreference.primary\n          }),\n          (_err, _reply) => commandHandler(_err as MongoError, _reply)\n        );\n      }\n\n      commandHandler(err as MongoError, reply);\n    }\n  );\n}\n\n/** @public */\nexport type ServerSessionId = { id: Binary };\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nexport class ServerSession {\n  id: ServerSessionId;\n  lastUse: number;\n  txnNumber: number;\n  isDirty: boolean;\n\n  /** @internal */\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes: number): boolean {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nexport class ServerSessionPool {\n  topology: Topology;\n  sessions: ServerSession[];\n\n  constructor(topology: Topology) {\n    if (topology == null) {\n      throw new MongoDriverError('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n\n  /** Ends all sessions in the session pool */\n  endAllPooledSessions(callback?: Callback<void>): void {\n    if (this.sessions.length) {\n      this.topology.endSessions(\n        this.sessions.map((session: ServerSession) => session.id),\n        () => {\n          this.sessions = [];\n          if (typeof callback === 'function') {\n            callback();\n          }\n        }\n      );\n\n      return;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire(): ServerSession {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;\n\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n      if (session && !session.hasTimedOut(sessionTimeoutMinutes)) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session: ServerSession): void {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nexport function commandSupportsReadConcern(command: Document, options?: Document): boolean {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (\n    command.mapReduce &&\n    options &&\n    options.out &&\n    (options.out.inline === 1 || options.out === 'inline')\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n */\nexport function applySession(\n  session: ClientSession,\n  command: Document,\n  options?: CommandOptions\n): MongoDriverError | undefined {\n  // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n  if (session.hasEnded) {\n    return new MongoDriverError('Attempted to use a session that has ended');\n  }\n\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new MongoDriverError('Unable to acquire server session');\n  }\n\n  // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  // FIXME: NODE-2781, this check for write concern shouldn't be happening here, but instead during command construction\n  if (options && options.writeConcern && (options.writeConcern as WriteConcern).w === 0) {\n    if (session && session.explicit) {\n      return new MongoDriverError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  // first apply non-transaction-specific sessions data\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = options?.willRetryWrite || false;\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    if (\n      session.supports.causalConsistency &&\n      session.operationTime &&\n      commandSupportsReadConcern(command, options)\n    ) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || { level: ReadConcernLevel.snapshot };\n      if (session[kSnapshotTime] !== undefined) {\n        Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n      }\n    }\n\n    return;\n  }\n\n  // now attempt to apply transaction-specific sessions data\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n}\n\nexport function updateSessionFromResponse(session: ClientSession, document: Document): void {\n  if (document.$clusterTime) {\n    resolveClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] === undefined) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}