{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nconst crypto = require(\"crypto\");\nconst bson_1 = require(\"../../bson\");\nconst error_1 = require(\"../../error\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst utils_1 = require(\"../../utils\");\nconst deps_1 = require(\"../../deps\");\nconst defaultAuthProviders_1 = require(\"./defaultAuthProviders\");\nclass ScramSHA extends auth_provider_1.AuthProvider {\n  constructor(cryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      return callback(new error_1.MongoDriverError('AuthContext must provide credentials.'));\n    }\n    if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n      utils_1.emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      }\n      // store the nonce for later use\n      Object.assign(authContext, {\n        nonce\n      });\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n  auth(authContext, callback) {\n    const response = authContext.response;\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n}\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA1 : defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const {\n    connection,\n    credentials\n  } = authContext;\n  if (!credentials) {\n    return callback(new error_1.MongoDriverError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoDriverError('AuthContext must contain a valid nonce property'));\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(utils_1.ns(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  if (!credentials) {\n    return callback(new error_1.MongoDriverError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoDriverError('Unable to continue SCRAM without valid nonce'));\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in deps_1.saslprep ? password : deps_1.saslprep(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n  const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(new error_1.MongoDriverError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    callback(new error_1.MongoDriverError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  }\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new bson_1.Binary(Buffer.from(clientFinal))\n  };\n  connection.command(utils_1.ns(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n    const err = resolveError(_err, r);\n    if (err) {\n      return callback(err);\n    }\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new error_1.MongoDriverError('Server returned an invalid signature'));\n      return;\n    }\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(utils_1.ns(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n  });\n}\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n  return dict;\n}\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoDriverError('username must be a string');\n  }\n  if (typeof password !== 'string') {\n    throw new error_1.MongoDriverError('password must be a string');\n  }\n  if (password.length === 0) {\n    throw new error_1.MongoDriverError('password cannot be empty');\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n  const length = Math.max(a.length, b.length);\n  const res = [];\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n  return result === 0;\n}\nfunction resolveError(err, result) {\n  if (err) return err;\n  if (result) {\n    if (result.$err || result.errmsg) return new error_1.MongoServerError(result);\n  }\n}\nclass ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n}\nexports.ScramSHA1 = ScramSHA1;\nclass ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n}\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"names":["crypto","require","bson_1","error_1","auth_provider_1","utils_1","deps_1","defaultAuthProviders_1","ScramSHA","AuthProvider","constructor","cryptoMethod","prepare","handshakeDoc","authContext","callback","credentials","MongoDriverError","saslprep","emitWarning","randomBytes","err","nonce","Object","assign","request","speculativeAuthenticate","makeFirstMessage","db","source","undefined","auth","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","Buffer","concat","from","toString","mechanism","AuthMechanism","MONGODB_SCRAM_SHA1","MONGODB_SCRAM_SHA256","saslStart","payload","Binary","autoAuthorize","options","skipEmptyExchange","connection","saslStartCmd","command","ns","_err","result","resolveError","password","processedPassword","passwordDigest","e","isBuffer","dict","parsePayload","value","iterations","parseInt","i","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","$err","errmsg","MongoServerError","ScramSHA1","exports","ScramSHA256"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\cmap\\auth\\scram.ts"],"sourcesContent":["import * as crypto from 'crypto';\nimport { Binary, Document } from '../../bson';\nimport { AnyError, MongoDriverError, MongoServerError } from '../../error';\nimport { AuthProvider, AuthContext } from './auth_provider';\nimport { Callback, ns, emitWarning } from '../../utils';\nimport type { MongoCredentials } from './mongo_credentials';\nimport type { HandshakeDocument } from '../connect';\n\nimport { saslprep } from '../../deps';\nimport { AuthMechanism } from './defaultAuthProviders';\n\ntype CryptoMethod = 'sha1' | 'sha256';\n\nclass ScramSHA extends AuthProvider {\n  cryptoMethod: CryptoMethod;\n  constructor(cryptoMethod: CryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc: HandshakeDocument, authContext: AuthContext, callback: Callback) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n      return callback(new MongoDriverError('AuthContext must provide credentials.'));\n    }\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      }\n\n      // store the nonce for later use\n      Object.assign(authContext, { nonce });\n\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext: AuthContext, callback: Callback) {\n    const response = authContext.response;\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(\n        this.cryptoMethod,\n        response.speculativeAuthenticate,\n        authContext,\n        callback\n      );\n\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n}\n\nfunction cleanUsername(username: string) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username: string, nonce: Buffer) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([\n    Buffer.from('n=', 'utf8'),\n    Buffer.from(username, 'utf8'),\n    Buffer.from(',r=', 'utf8'),\n    Buffer.from(nonce.toString('base64'), 'utf8')\n  ]);\n}\n\nfunction makeFirstMessage(\n  cryptoMethod: CryptoMethod,\n  credentials: MongoCredentials,\n  nonce: Buffer\n) {\n  const username = cleanUsername(credentials.username);\n  const mechanism =\n    cryptoMethod === 'sha1' ? AuthMechanism.MONGODB_SCRAM_SHA1 : AuthMechanism.MONGODB_SCRAM_SHA256;\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\n    ),\n    autoAuthorize: 1,\n    options: { skipEmptyExchange: true }\n  };\n}\n\nfunction executeScram(cryptoMethod: CryptoMethod, authContext: AuthContext, callback: Callback) {\n  const { connection, credentials } = authContext;\n  if (!credentials) {\n    return callback(new MongoDriverError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(new MongoDriverError('AuthContext must contain a valid nonce property'));\n  }\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(ns(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(\n  cryptoMethod: CryptoMethod,\n  response: Document,\n  authContext: AuthContext,\n  callback: Callback\n) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  if (!credentials) {\n    return callback(new MongoDriverError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(new MongoDriverError('Unable to continue SCRAM without valid nonce'));\n  }\n  const nonce = authContext.nonce;\n\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in saslprep ? password : saslprep(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload)\n    ? new Binary(response.payload)\n    : response.payload;\n  const dict = parsePayload(payload.value());\n\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(\n      new MongoDriverError(`Server returned an invalid iteration count ${iterations}`),\n      false\n    );\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoDriverError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(\n    processedPassword,\n    Buffer.from(salt, 'base64'),\n    iterations,\n    cryptoMethod\n  );\n\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(\n    ','\n  );\n\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n\n  connection.command(ns(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n    const err = resolveError(_err, r);\n    if (err) {\n      return callback(err);\n    }\n\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoDriverError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n\n    connection.command(ns(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n  });\n}\n\nfunction parsePayload(payload: string) {\n  const dict: Document = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username: string, password: string) {\n  if (typeof username !== 'string') {\n    throw new MongoDriverError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoDriverError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoDriverError('password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a: Buffer, b: Buffer) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method: CryptoMethod, text: Buffer) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method: CryptoMethod, key: Buffer, text: Buffer | string) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\ninterface HICache {\n  [key: string]: Buffer;\n}\n\nlet _hiCache: HICache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data: string, salt: Buffer, iterations: number, cryptoMethod: CryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs: Buffer, rhs: Uint8Array) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err?: AnyError, result?: Document) {\n  if (err) return err;\n  if (result) {\n    if (result.$err || result.errmsg) return new MongoServerError(result);\n  }\n}\n\nexport class ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n}\n\nexport class ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,MAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AACA,MAAAG,eAAA,GAAAH,OAAA;AACA,MAAAI,OAAA,GAAAJ,OAAA;AAIA,MAAAK,MAAA,GAAAL,OAAA;AACA,MAAAM,sBAAA,GAAAN,OAAA;AAIA,MAAMO,QAAS,SAAQJ,eAAA,CAAAK,YAAY;EAEjCC,YAAYC,YAA0B;IACpC,KAAK,EAAE;IACP,IAAI,CAACA,YAAY,GAAGA,YAAY,IAAI,MAAM;EAC5C;EAEAC,OAAOA,CAACC,YAA+B,EAAEC,WAAwB,EAAEC,QAAkB;IACnF,MAAMJ,YAAY,GAAG,IAAI,CAACA,YAAY;IACtC,MAAMK,WAAW,GAAGF,WAAW,CAACE,WAAW;IAC3C,IAAI,CAACA,WAAW,EAAE;MAChB,OAAOD,QAAQ,CAAC,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,uCAAuC,CAAC,CAAC;;IAEhF,IAAIN,YAAY,KAAK,QAAQ,IAAIL,MAAA,CAAAY,QAAQ,IAAI,IAAI,EAAE;MACjDb,OAAA,CAAAc,WAAW,CAAC,yEAAyE,CAAC;;IAGxFnB,MAAM,CAACoB,WAAW,CAAC,EAAE,EAAE,CAACC,GAAG,EAAEC,KAAK,KAAI;MACpC,IAAID,GAAG,EAAE;QACP,OAAON,QAAQ,CAACM,GAAG,CAAC;;MAGtB;MACAE,MAAM,CAACC,MAAM,CAACV,WAAW,EAAE;QAAEQ;MAAK,CAAE,CAAC;MAErC,MAAMG,OAAO,GAAGF,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEX,YAAY,EAAE;QAC9Ca,uBAAuB,EAAEH,MAAM,CAACC,MAAM,CAACG,gBAAgB,CAAChB,YAAY,EAAEK,WAAW,EAAEM,KAAK,CAAC,EAAE;UACzFM,EAAE,EAAEZ,WAAW,CAACa;SACjB;OACF,CAAC;MAEFd,QAAQ,CAACe,SAAS,EAAEL,OAAO,CAAC;IAC9B,CAAC,CAAC;EACJ;EAEAM,IAAIA,CAACjB,WAAwB,EAAEC,QAAkB;IAC/C,MAAMiB,QAAQ,GAAGlB,WAAW,CAACkB,QAAQ;IACrC,IAAIA,QAAQ,IAAIA,QAAQ,CAACN,uBAAuB,EAAE;MAChDO,yBAAyB,CACvB,IAAI,CAACtB,YAAY,EACjBqB,QAAQ,CAACN,uBAAuB,EAChCZ,WAAW,EACXC,QAAQ,CACT;MAED;;IAGFmB,YAAY,CAAC,IAAI,CAACvB,YAAY,EAAEG,WAAW,EAAEC,QAAQ,CAAC;EACxD;;AAGF,SAASoB,aAAaA,CAACC,QAAgB;EACrC,OAAOA,QAAQ,CAACC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAACA,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC;AACzD;AAEA,SAASC,sBAAsBA,CAACF,QAAgB,EAAEd,KAAa;EAC7D;EACA;EACA,OAAOiB,MAAM,CAACC,MAAM,CAAC,CACnBD,MAAM,CAACE,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,EACzBF,MAAM,CAACE,IAAI,CAACL,QAAQ,EAAE,MAAM,CAAC,EAC7BG,MAAM,CAACE,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,EAC1BF,MAAM,CAACE,IAAI,CAACnB,KAAK,CAACoB,QAAQ,CAAC,QAAQ,CAAC,EAAE,MAAM,CAAC,CAC9C,CAAC;AACJ;AAEA,SAASf,gBAAgBA,CACvBhB,YAA0B,EAC1BK,WAA6B,EAC7BM,KAAa;EAEb,MAAMc,QAAQ,GAAGD,aAAa,CAACnB,WAAW,CAACoB,QAAQ,CAAC;EACpD,MAAMO,SAAS,GACbhC,YAAY,KAAK,MAAM,GAAGJ,sBAAA,CAAAqC,aAAa,CAACC,kBAAkB,GAAGtC,sBAAA,CAAAqC,aAAa,CAACE,oBAAoB;EAEjG;EACA;EACA,OAAO;IACLC,SAAS,EAAE,CAAC;IACZJ,SAAS;IACTK,OAAO,EAAE,IAAI9C,MAAA,CAAA+C,MAAM,CACjBV,MAAM,CAACC,MAAM,CAAC,CAACD,MAAM,CAACE,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,EAAEH,sBAAsB,CAACF,QAAQ,EAAEd,KAAK,CAAC,CAAC,CAAC,CACrF;IACD4B,aAAa,EAAE,CAAC;IAChBC,OAAO,EAAE;MAAEC,iBAAiB,EAAE;IAAI;GACnC;AACH;AAEA,SAASlB,YAAYA,CAACvB,YAA0B,EAAEG,WAAwB,EAAEC,QAAkB;EAC5F,MAAM;IAAEsC,UAAU;IAAErC;EAAW,CAAE,GAAGF,WAAW;EAC/C,IAAI,CAACE,WAAW,EAAE;IAChB,OAAOD,QAAQ,CAAC,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,uCAAuC,CAAC,CAAC;;EAEhF,IAAI,CAACH,WAAW,CAACQ,KAAK,EAAE;IACtB,OAAOP,QAAQ,CAAC,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,iDAAiD,CAAC,CAAC;;EAE1F,MAAMK,KAAK,GAAGR,WAAW,CAACQ,KAAK;EAC/B,MAAMM,EAAE,GAAGZ,WAAW,CAACa,MAAM;EAE7B,MAAMyB,YAAY,GAAG3B,gBAAgB,CAAChB,YAAY,EAAEK,WAAW,EAAEM,KAAK,CAAC;EACvE+B,UAAU,CAACE,OAAO,CAAClD,OAAA,CAAAmD,EAAE,CAAC,GAAG5B,EAAE,OAAO,CAAC,EAAE0B,YAAY,EAAExB,SAAS,EAAE,CAAC2B,IAAI,EAAEC,MAAM,KAAI;IAC7E,MAAMrC,GAAG,GAAGsC,YAAY,CAACF,IAAI,EAAEC,MAAM,CAAC;IACtC,IAAIrC,GAAG,EAAE;MACP,OAAON,QAAQ,CAACM,GAAG,CAAC;;IAGtBY,yBAAyB,CAACtB,YAAY,EAAE+C,MAAM,EAAE5C,WAAW,EAAEC,QAAQ,CAAC;EACxE,CAAC,CAAC;AACJ;AAEA,SAASkB,yBAAyBA,CAChCtB,YAA0B,EAC1BqB,QAAkB,EAClBlB,WAAwB,EACxBC,QAAkB;EAElB,MAAMsC,UAAU,GAAGvC,WAAW,CAACuC,UAAU;EACzC,MAAMrC,WAAW,GAAGF,WAAW,CAACE,WAAW;EAC3C,IAAI,CAACA,WAAW,EAAE;IAChB,OAAOD,QAAQ,CAAC,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,uCAAuC,CAAC,CAAC;;EAEhF,IAAI,CAACH,WAAW,CAACQ,KAAK,EAAE;IACtB,OAAOP,QAAQ,CAAC,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,8CAA8C,CAAC,CAAC;;EAEvF,MAAMK,KAAK,GAAGR,WAAW,CAACQ,KAAK;EAE/B,MAAMM,EAAE,GAAGZ,WAAW,CAACa,MAAM;EAC7B,MAAMO,QAAQ,GAAGD,aAAa,CAACnB,WAAW,CAACoB,QAAQ,CAAC;EACpD,MAAMwB,QAAQ,GAAG5C,WAAW,CAAC4C,QAAQ;EAErC,IAAIC,iBAAiB;EACrB,IAAIlD,YAAY,KAAK,QAAQ,EAAE;IAC7BkD,iBAAiB,GAAG,cAAc,IAAIvD,MAAA,CAAAY,QAAQ,GAAG0C,QAAQ,GAAGtD,MAAA,CAAAY,QAAQ,CAAC0C,QAAQ,CAAC;GAC/E,MAAM;IACL,IAAI;MACFC,iBAAiB,GAAGC,cAAc,CAAC1B,QAAQ,EAAEwB,QAAQ,CAAC;KACvD,CAAC,OAAOG,CAAC,EAAE;MACV,OAAOhD,QAAQ,CAACgD,CAAC,CAAC;;;EAItB,MAAMf,OAAO,GAAGT,MAAM,CAACyB,QAAQ,CAAChC,QAAQ,CAACgB,OAAO,CAAC,GAC7C,IAAI9C,MAAA,CAAA+C,MAAM,CAACjB,QAAQ,CAACgB,OAAO,CAAC,GAC5BhB,QAAQ,CAACgB,OAAO;EACpB,MAAMiB,IAAI,GAAGC,YAAY,CAAClB,OAAO,CAACmB,KAAK,EAAE,CAAC;EAE1C,MAAMC,UAAU,GAAGC,QAAQ,CAACJ,IAAI,CAACK,CAAC,EAAE,EAAE,CAAC;EACvC,IAAIF,UAAU,IAAIA,UAAU,GAAG,IAAI,EAAE;IACnCrD,QAAQ,CACN,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,8CAA8CmD,UAAU,EAAE,CAAC,EAChF,KAAK,CACN;IACD;;EAGF,MAAMG,IAAI,GAAGN,IAAI,CAACO,CAAC;EACnB,MAAMC,MAAM,GAAGR,IAAI,CAACS,CAAC;EACrB,IAAID,MAAM,CAACE,UAAU,CAAC,OAAO,CAAC,EAAE;IAC9B5D,QAAQ,CAAC,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,qCAAqCwD,MAAM,EAAE,CAAC,EAAE,KAAK,CAAC;IACpF;;EAGF;EACA,MAAMG,YAAY,GAAG,YAAYH,MAAM,EAAE;EACzC,MAAMI,cAAc,GAAGC,EAAE,CACvBjB,iBAAiB,EACjBtB,MAAM,CAACE,IAAI,CAAC8B,IAAI,EAAE,QAAQ,CAAC,EAC3BH,UAAU,EACVzD,YAAY,CACb;EAED,MAAMoE,SAAS,GAAGC,IAAI,CAACrE,YAAY,EAAEkE,cAAc,EAAE,YAAY,CAAC;EAClE,MAAMI,SAAS,GAAGD,IAAI,CAACrE,YAAY,EAAEkE,cAAc,EAAE,YAAY,CAAC;EAClE,MAAMK,SAAS,GAAGC,CAAC,CAACxE,YAAY,EAAEoE,SAAS,CAAC;EAC5C,MAAMK,WAAW,GAAG,CAAC9C,sBAAsB,CAACF,QAAQ,EAAEd,KAAK,CAAC,EAAE0B,OAAO,CAACmB,KAAK,EAAE,EAAES,YAAY,CAAC,CAACS,IAAI,CAC/F,GAAG,CACJ;EAED,MAAMC,eAAe,GAAGN,IAAI,CAACrE,YAAY,EAAEuE,SAAS,EAAEE,WAAW,CAAC;EAClE,MAAMG,WAAW,GAAG,KAAKC,GAAG,CAACT,SAAS,EAAEO,eAAe,CAAC,EAAE;EAC1D,MAAMG,WAAW,GAAG,CAACb,YAAY,EAAEW,WAAW,CAAC,CAACF,IAAI,CAAC,GAAG,CAAC;EAEzD,MAAMK,eAAe,GAAGV,IAAI,CAACrE,YAAY,EAAEsE,SAAS,EAAEG,WAAW,CAAC;EAClE,MAAMO,eAAe,GAAG;IACtBC,YAAY,EAAE,CAAC;IACfC,cAAc,EAAE7D,QAAQ,CAAC6D,cAAc;IACvC7C,OAAO,EAAE,IAAI9C,MAAA,CAAA+C,MAAM,CAACV,MAAM,CAACE,IAAI,CAACgD,WAAW,CAAC;GAC7C;EAEDpC,UAAU,CAACE,OAAO,CAAClD,OAAA,CAAAmD,EAAE,CAAC,GAAG5B,EAAE,OAAO,CAAC,EAAE+D,eAAe,EAAE7D,SAAS,EAAE,CAAC2B,IAAI,EAAEiB,CAAC,KAAI;IAC3E,MAAMrD,GAAG,GAAGsC,YAAY,CAACF,IAAI,EAAEiB,CAAC,CAAC;IACjC,IAAIrD,GAAG,EAAE;MACP,OAAON,QAAQ,CAACM,GAAG,CAAC;;IAGtB,MAAMyE,cAAc,GAAG5B,YAAY,CAACQ,CAAC,CAAC1B,OAAO,CAACmB,KAAK,EAAE,CAAC;IACtD,IAAI,CAAC4B,aAAa,CAACxD,MAAM,CAACE,IAAI,CAACqD,cAAc,CAACE,CAAC,EAAE,QAAQ,CAAC,EAAEN,eAAe,CAAC,EAAE;MAC5E3E,QAAQ,CAAC,IAAIZ,OAAA,CAAAc,gBAAgB,CAAC,sCAAsC,CAAC,CAAC;MACtE;;IAGF,IAAI,CAACyD,CAAC,IAAIA,CAAC,CAACuB,IAAI,KAAK,KAAK,EAAE;MAC1B,OAAOlF,QAAQ,CAACM,GAAG,EAAEqD,CAAC,CAAC;;IAGzB,MAAMwB,oBAAoB,GAAG;MAC3BN,YAAY,EAAE,CAAC;MACfC,cAAc,EAAEnB,CAAC,CAACmB,cAAc;MAChC7C,OAAO,EAAET,MAAM,CAAC4D,KAAK,CAAC,CAAC;KACxB;IAED9C,UAAU,CAACE,OAAO,CAAClD,OAAA,CAAAmD,EAAE,CAAC,GAAG5B,EAAE,OAAO,CAAC,EAAEsE,oBAAoB,EAAEpE,SAAS,EAAEf,QAAQ,CAAC;EACjF,CAAC,CAAC;AACJ;AAEA,SAASmD,YAAYA,CAAClB,OAAe;EACnC,MAAMiB,IAAI,GAAa,EAAE;EACzB,MAAMmC,KAAK,GAAGpD,OAAO,CAACqD,KAAK,CAAC,GAAG,CAAC;EAChC,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8B,KAAK,CAACE,MAAM,EAAEhC,CAAC,EAAE,EAAE;IACrC,MAAMiC,UAAU,GAAGH,KAAK,CAAC9B,CAAC,CAAC,CAAC+B,KAAK,CAAC,GAAG,CAAC;IACtCpC,IAAI,CAACsC,UAAU,CAAC,CAAC,CAAC,CAAC,GAAGA,UAAU,CAAC,CAAC,CAAC;;EAGrC,OAAOtC,IAAI;AACb;AAEA,SAASH,cAAcA,CAAC1B,QAAgB,EAAEwB,QAAgB;EACxD,IAAI,OAAOxB,QAAQ,KAAK,QAAQ,EAAE;IAChC,MAAM,IAAIjC,OAAA,CAAAc,gBAAgB,CAAC,2BAA2B,CAAC;;EAGzD,IAAI,OAAO2C,QAAQ,KAAK,QAAQ,EAAE;IAChC,MAAM,IAAIzD,OAAA,CAAAc,gBAAgB,CAAC,2BAA2B,CAAC;;EAGzD,IAAI2C,QAAQ,CAAC0C,MAAM,KAAK,CAAC,EAAE;IACzB,MAAM,IAAInG,OAAA,CAAAc,gBAAgB,CAAC,0BAA0B,CAAC;;EAGxD,MAAMuF,GAAG,GAAGxG,MAAM,CAACyG,UAAU,CAAC,KAAK,CAAC;EACpCD,GAAG,CAACE,MAAM,CAAC,GAAGtE,QAAQ,UAAUwB,QAAQ,EAAE,EAAE,MAAM,CAAC;EACnD,OAAO4C,GAAG,CAACG,MAAM,CAAC,KAAK,CAAC;AAC1B;AAEA;AACA,SAASnB,GAAGA,CAACoB,CAAS,EAAEC,CAAS;EAC/B,IAAI,CAACtE,MAAM,CAACyB,QAAQ,CAAC4C,CAAC,CAAC,EAAE;IACvBA,CAAC,GAAGrE,MAAM,CAACE,IAAI,CAACmE,CAAC,CAAC;;EAGpB,IAAI,CAACrE,MAAM,CAACyB,QAAQ,CAAC6C,CAAC,CAAC,EAAE;IACvBA,CAAC,GAAGtE,MAAM,CAACE,IAAI,CAACoE,CAAC,CAAC;;EAGpB,MAAMP,MAAM,GAAGQ,IAAI,CAACC,GAAG,CAACH,CAAC,CAACN,MAAM,EAAEO,CAAC,CAACP,MAAM,CAAC;EAC3C,MAAMU,GAAG,GAAG,EAAE;EAEd,KAAK,IAAI1C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,MAAM,EAAEhC,CAAC,IAAI,CAAC,EAAE;IAClC0C,GAAG,CAACC,IAAI,CAACL,CAAC,CAACtC,CAAC,CAAC,GAAGuC,CAAC,CAACvC,CAAC,CAAC,CAAC;;EAGvB,OAAO/B,MAAM,CAACE,IAAI,CAACuE,GAAG,CAAC,CAACtE,QAAQ,CAAC,QAAQ,CAAC;AAC5C;AAEA,SAASyC,CAACA,CAAC+B,MAAoB,EAAEC,IAAY;EAC3C,OAAOnH,MAAM,CAACyG,UAAU,CAACS,MAAM,CAAC,CAACR,MAAM,CAACS,IAAI,CAAC,CAACR,MAAM,EAAE;AACxD;AAEA,SAAS3B,IAAIA,CAACkC,MAAoB,EAAEE,GAAW,EAAED,IAAqB;EACpE,OAAOnH,MAAM,CAACqH,UAAU,CAACH,MAAM,EAAEE,GAAG,CAAC,CAACV,MAAM,CAACS,IAAI,CAAC,CAACR,MAAM,EAAE;AAC7D;AAMA,IAAIW,QAAQ,GAAY,EAAE;AAC1B,IAAIC,aAAa,GAAG,CAAC;AACrB,SAASC,aAAaA,CAAA;EACpBF,QAAQ,GAAG,EAAE;EACbC,aAAa,GAAG,CAAC;AACnB;AAEA,MAAME,WAAW,GAAG;EAClBC,MAAM,EAAE,EAAE;EACVC,IAAI,EAAE;CACP;AAED,SAAS7C,EAAEA,CAAC8C,IAAY,EAAErD,IAAY,EAAEH,UAAkB,EAAEzD,YAA0B;EACpF;EACA,MAAMyG,GAAG,GAAG,CAACQ,IAAI,EAAErD,IAAI,CAAC7B,QAAQ,CAAC,QAAQ,CAAC,EAAE0B,UAAU,CAAC,CAACiB,IAAI,CAAC,GAAG,CAAC;EACjE,IAAIiC,QAAQ,CAACF,GAAG,CAAC,KAAKtF,SAAS,EAAE;IAC/B,OAAOwF,QAAQ,CAACF,GAAG,CAAC;;EAGtB;EACA,MAAMS,UAAU,GAAG7H,MAAM,CAAC8H,UAAU,CAClCF,IAAI,EACJrD,IAAI,EACJH,UAAU,EACVqD,WAAW,CAAC9G,YAAY,CAAC,EACzBA,YAAY,CACb;EAED;EACA,IAAI4G,aAAa,IAAI,GAAG,EAAE;IACxBC,aAAa,EAAE;;EAGjBF,QAAQ,CAACF,GAAG,CAAC,GAAGS,UAAU;EAC1BN,aAAa,IAAI,CAAC;EAClB,OAAOM,UAAU;AACnB;AAEA,SAAS9B,aAAaA,CAACgC,GAAW,EAAEC,GAAe;EACjD,IAAID,GAAG,CAACzB,MAAM,KAAK0B,GAAG,CAAC1B,MAAM,EAAE;IAC7B,OAAO,KAAK;;EAGd,IAAI,OAAOtG,MAAM,CAACiI,eAAe,KAAK,UAAU,EAAE;IAChD,OAAOjI,MAAM,CAACiI,eAAe,CAACF,GAAG,EAAEC,GAAG,CAAC;;EAGzC,IAAItE,MAAM,GAAG,CAAC;EACd,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,GAAG,CAACzB,MAAM,EAAEhC,CAAC,EAAE,EAAE;IACnCZ,MAAM,IAAIqE,GAAG,CAACzD,CAAC,CAAC,GAAG0D,GAAG,CAAC1D,CAAC,CAAC;;EAG3B,OAAOZ,MAAM,KAAK,CAAC;AACrB;AAEA,SAASC,YAAYA,CAACtC,GAAc,EAAEqC,MAAiB;EACrD,IAAIrC,GAAG,EAAE,OAAOA,GAAG;EACnB,IAAIqC,MAAM,EAAE;IACV,IAAIA,MAAM,CAACwE,IAAI,IAAIxE,MAAM,CAACyE,MAAM,EAAE,OAAO,IAAIhI,OAAA,CAAAiI,gBAAgB,CAAC1E,MAAM,CAAC;;AAEzE;AAEA,MAAa2E,SAAU,SAAQ7H,QAAQ;EACrCE,YAAA;IACE,KAAK,CAAC,MAAM,CAAC;EACf;;AAHF4H,OAAA,CAAAD,SAAA,GAAAA,SAAA;AAMA,MAAaE,WAAY,SAAQ/H,QAAQ;EACvCE,YAAA;IACE,KAAK,CAAC,QAAQ,CAAC;EACjB;;AAHF4H,OAAA,CAAAC,WAAA,GAAAA,WAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}