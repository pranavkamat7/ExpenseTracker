{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\nconst command_1 = require(\"./command\");\nconst read_preference_1 = require(\"../read_preference\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nexports.DB_AGGREGATE_COLLECTION = 1;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n/** @internal */\nclass AggregateOperation extends command_1.CommandOperation {\n  constructor(parent, pipeline, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : exports.DB_AGGREGATE_COLLECTION;\n    this.pipeline = pipeline;\n    // determine if we have a write stage, override read preference if so\n    this.hasWriteStage = false;\n    if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {\n      this.pipeline = this.pipeline.concat({\n        $out: options.out\n      });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n    if (this.hasWriteStage) {\n      this.readPreference = read_preference_1.ReadPreference.primary;\n    }\n    if (this.explain && this.writeConcern) {\n      throw new error_1.MongoDriverError('\"explain\" cannot be used on an aggregate call with writeConcern');\n    }\n    if ((options === null || options === void 0 ? void 0 : options.cursor) != null && typeof options.cursor !== 'object') {\n      throw new error_1.MongoDriverError('cursor options must be an object');\n    }\n  }\n  get canRetryRead() {\n    return !this.hasWriteStage;\n  }\n  addToPipeline(stage) {\n    this.pipeline.push(stage);\n  }\n  execute(server, session, callback) {\n    const options = this.options;\n    const serverWireVersion = utils_1.maxWireVersion(server);\n    const command = {\n      aggregate: this.target,\n      pipeline: this.pipeline\n    };\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n    if (serverWireVersion >= 5) {\n      if (this.hasWriteStage && this.writeConcern) {\n        Object.assign(command, {\n          writeConcern: this.writeConcern\n        });\n      }\n    }\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n    if (options.let) {\n      command.let = options.let;\n    }\n    command.cursor = options.cursor || {};\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n    super.executeCommand(server, session, command, callback);\n  }\n}\nexports.AggregateOperation = AggregateOperation;\noperation_1.defineAspects(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);","map":{"version":3,"names":["command_1","require","read_preference_1","error_1","utils_1","operation_1","exports","DB_AGGREGATE_COLLECTION","MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT","AggregateOperation","CommandOperation","constructor","parent","pipeline","options","target","s","namespace","collection","hasWriteStage","out","concat","$out","length","finalStage","$merge","readPreference","ReadPreference","primary","explain","writeConcern","MongoDriverError","cursor","canRetryRead","addToPipeline","stage","push","execute","server","session","callback","serverWireVersion","maxWireVersion","command","aggregate","readConcern","undefined","Object","assign","bypassDocumentValidation","allowDiskUse","hint","let","batchSize","executeCommand","defineAspects","Aspect","READ_OPERATION","RETRYABLE","EXPLAINABLE"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\operations\\aggregate.ts"],"sourcesContent":["import {\n  CommandOperation,\n  CommandOperationOptions,\n  OperationParent,\n  CollationOptions\n} from './command';\nimport { ReadPreference } from '../read_preference';\nimport { MongoDriverError } from '../error';\nimport { maxWireVersion } from '../utils';\nimport { Aspect, defineAspects, Hint } from './operation';\nimport type { Callback } from '../utils';\nimport type { Document } from '../bson';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\n\n/** @internal */\nexport const DB_AGGREGATE_COLLECTION = 1 as const;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8 as const;\n\n/** @public */\nexport interface AggregateOptions extends CommandOperationOptions {\n  /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>). */\n  allowDiskUse?: boolean;\n  /** The number of documents to return per batch. See [aggregation documentation](https://docs.mongodb.com/manual/reference/command/aggregate). */\n  batchSize?: number;\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\n  bypassDocumentValidation?: boolean;\n  /** Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */\n  cursor?: Document;\n  /** specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point. */\n  maxTimeMS?: number;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */\n  maxAwaitTimeMS?: number;\n  /** Specify collation. */\n  collation?: CollationOptions;\n  /** Add an index selection hint to an aggregation command */\n  hint?: Hint;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  out?: string;\n}\n\n/** @internal */\nexport class AggregateOperation<T = Document> extends CommandOperation<T> {\n  options: AggregateOptions;\n  target: string | typeof DB_AGGREGATE_COLLECTION;\n  pipeline: Document[];\n  hasWriteStage: boolean;\n\n  constructor(parent: OperationParent, pipeline: Document[], options?: AggregateOptions) {\n    super(parent, options);\n\n    this.options = options ?? {};\n    this.target =\n      parent.s.namespace && parent.s.namespace.collection\n        ? parent.s.namespace.collection\n        : DB_AGGREGATE_COLLECTION;\n\n    this.pipeline = pipeline;\n\n    // determine if we have a write stage, override read preference if so\n    this.hasWriteStage = false;\n    if (typeof options?.out === 'string') {\n      this.pipeline = this.pipeline.concat({ $out: options.out });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n\n    if (this.hasWriteStage) {\n      this.readPreference = ReadPreference.primary;\n    }\n\n    if (this.explain && this.writeConcern) {\n      throw new MongoDriverError('\"explain\" cannot be used on an aggregate call with writeConcern');\n    }\n\n    if (options?.cursor != null && typeof options.cursor !== 'object') {\n      throw new MongoDriverError('cursor options must be an object');\n    }\n  }\n\n  get canRetryRead(): boolean {\n    return !this.hasWriteStage;\n  }\n\n  addToPipeline(stage: Document): void {\n    this.pipeline.push(stage);\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<T>): void {\n    const options: AggregateOptions = this.options;\n    const serverWireVersion = maxWireVersion(server);\n    const command: Document = { aggregate: this.target, pipeline: this.pipeline };\n\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n\n    if (serverWireVersion >= 5) {\n      if (this.hasWriteStage && this.writeConcern) {\n        Object.assign(command, { writeConcern: this.writeConcern });\n      }\n    }\n\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    }\n\n    command.cursor = options.cursor || {};\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n}\n\ndefineAspects(AggregateOperation, [Aspect.READ_OPERATION, Aspect.RETRYABLE, Aspect.EXPLAINABLE]);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}