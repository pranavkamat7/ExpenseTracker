{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregationCursor = void 0;\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\n/** @internal */\nconst kParent = Symbol('parent');\n/** @internal */\nconst kPipeline = Symbol('pipeline');\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nclass AggregationCursor extends abstract_cursor_1.AbstractCursor {\n  /** @internal */\n  constructor(parent, topology, namespace, pipeline = [], options = {}) {\n    super(topology, namespace, options);\n    this[kParent] = parent;\n    this[kPipeline] = pipeline;\n    this[kOptions] = options;\n  }\n  get pipeline() {\n    return this[kPipeline];\n  }\n  clone() {\n    const clonedOptions = utils_1.mergeOptions({}, this[kOptions]);\n    delete clonedOptions.session;\n    return new AggregationCursor(this[kParent], this.topology, this.namespace, this[kPipeline], {\n      ...clonedOptions\n    });\n  }\n  map(transform) {\n    return super.map(transform);\n  }\n  /** @internal */\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this[kParent], this[kPipeline], {\n      ...this[kOptions],\n      ...this.cursorOptions,\n      session\n    });\n    execute_operation_1.executeOperation(this.topology, aggregateOperation, (err, response) => {\n      if (err || response == null) return callback(err);\n      // TODO: NODE-2882\n      callback(undefined, {\n        server: aggregateOperation.server,\n        session,\n        response\n      });\n    });\n  }\n  explain(verbosity, callback) {\n    if (typeof verbosity === 'function') callback = verbosity, verbosity = true;\n    if (verbosity === undefined) verbosity = true;\n    return execute_operation_1.executeOperation(this.topology, new aggregate_1.AggregateOperation(this[kParent], this[kPipeline], {\n      ...this[kOptions],\n      ...this.cursorOptions,\n      explain: verbosity\n    }), callback);\n  }\n  group($group) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $group\n    });\n    return this;\n  }\n  /** Add a limit stage to the aggregation pipeline */\n  limit($limit) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $limit\n    });\n    return this;\n  }\n  /** Add a match stage to the aggregation pipeline */\n  match($match) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $match\n    });\n    return this;\n  }\n  /** Add a out stage to the aggregation pipeline */\n  out($out) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $out\n    });\n    return this;\n  }\n  project($project) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $project\n    });\n    return this;\n  }\n  /** Add a lookup stage to the aggregation pipeline */\n  lookup($lookup) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $lookup\n    });\n    return this;\n  }\n  /** Add a redact stage to the aggregation pipeline */\n  redact($redact) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $redact\n    });\n    return this;\n  }\n  /** Add a skip stage to the aggregation pipeline */\n  skip($skip) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $skip\n    });\n    return this;\n  }\n  /** Add a sort stage to the aggregation pipeline */\n  sort($sort) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $sort\n    });\n    return this;\n  }\n  /** Add a unwind stage to the aggregation pipeline */\n  unwind($unwind) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $unwind\n    });\n    return this;\n  }\n  // deprecated methods\n  /** @deprecated Add a geoNear stage to the aggregation pipeline */\n  geoNear($geoNear) {\n    abstract_cursor_1.assertUninitialized(this);\n    this[kPipeline].push({\n      $geoNear\n    });\n    return this;\n  }\n}\nexports.AggregationCursor = AggregationCursor;","map":{"version":3,"names":["aggregate_1","require","abstract_cursor_1","execute_operation_1","utils_1","kParent","Symbol","kPipeline","kOptions","AggregationCursor","AbstractCursor","constructor","parent","topology","namespace","pipeline","options","clone","clonedOptions","mergeOptions","session","map","transform","_initialize","callback","aggregateOperation","AggregateOperation","cursorOptions","executeOperation","err","response","undefined","server","explain","verbosity","group","$group","assertUninitialized","push","limit","$limit","match","$match","out","$out","project","$project","lookup","$lookup","redact","$redact","skip","$skip","sort","$sort","unwind","$unwind","geoNear","$geoNear","exports"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\cursor\\aggregation_cursor.ts"],"sourcesContent":["import { AggregateOperation, AggregateOptions } from '../operations/aggregate';\nimport { AbstractCursor, assertUninitialized } from './abstract_cursor';\nimport { executeOperation, ExecutionResult } from '../operations/execute_operation';\nimport { mergeOptions } from '../utils';\nimport type { Document } from '../bson';\nimport type { Sort } from '../sort';\nimport type { Topology } from '../sdam/topology';\nimport type { Callback, MongoDBNamespace } from '../utils';\nimport type { ClientSession } from '../sessions';\nimport type { OperationParent } from '../operations/command';\nimport type { AbstractCursorOptions } from './abstract_cursor';\nimport type { ExplainVerbosityLike } from '../explain';\nimport type { Projection } from '../mongo_types';\n\n/** @public */\nexport interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {}\n\n/** @internal */\nconst kParent = Symbol('parent');\n/** @internal */\nconst kPipeline = Symbol('pipeline');\n/** @internal */\nconst kOptions = Symbol('options');\n\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nexport class AggregationCursor<TSchema = Document> extends AbstractCursor<TSchema> {\n  /** @internal */\n  [kParent]: OperationParent; // TODO: NODE-2883\n  /** @internal */\n  [kPipeline]: Document[];\n  /** @internal */\n  [kOptions]: AggregateOptions;\n\n  /** @internal */\n  constructor(\n    parent: OperationParent,\n    topology: Topology,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: AggregateOptions = {}\n  ) {\n    super(topology, namespace, options);\n\n    this[kParent] = parent;\n    this[kPipeline] = pipeline;\n    this[kOptions] = options;\n  }\n\n  get pipeline(): Document[] {\n    return this[kPipeline];\n  }\n\n  clone(): AggregationCursor<TSchema> {\n    const clonedOptions = mergeOptions({}, this[kOptions]);\n    delete clonedOptions.session;\n    return new AggregationCursor(this[kParent], this.topology, this.namespace, this[kPipeline], {\n      ...clonedOptions\n    });\n  }\n\n  map<T>(transform: (doc: TSchema) => T): AggregationCursor<T> {\n    return super.map(transform) as AggregationCursor<T>;\n  }\n\n  /** @internal */\n  _initialize(session: ClientSession | undefined, callback: Callback<ExecutionResult>): void {\n    const aggregateOperation = new AggregateOperation(this[kParent], this[kPipeline], {\n      ...this[kOptions],\n      ...this.cursorOptions,\n      session\n    });\n\n    executeOperation(this.topology, aggregateOperation, (err, response) => {\n      if (err || response == null) return callback(err);\n\n      // TODO: NODE-2882\n      callback(undefined, { server: aggregateOperation.server, session, response });\n    });\n  }\n\n  /** Execute the explain for the cursor */\n  explain(): Promise<Document>;\n  explain(callback: Callback): void;\n  explain(verbosity: ExplainVerbosityLike): Promise<Document>;\n  explain(\n    verbosity?: ExplainVerbosityLike | Callback,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof verbosity === 'function') (callback = verbosity), (verbosity = true);\n    if (verbosity === undefined) verbosity = true;\n\n    return executeOperation(\n      this.topology,\n      new AggregateOperation(this[kParent], this[kPipeline], {\n        ...this[kOptions], // NOTE: order matters here, we may need to refine this\n        ...this.cursorOptions,\n        explain: verbosity\n      }),\n      callback\n    );\n  }\n\n  /** Add a group stage to the aggregation pipeline */\n  group<T = TSchema>($group: Document): AggregationCursor<T>;\n  group($group: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $group });\n    return this;\n  }\n\n  /** Add a limit stage to the aggregation pipeline */\n  limit($limit: number): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $limit });\n    return this;\n  }\n\n  /** Add a match stage to the aggregation pipeline */\n  match($match: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $match });\n    return this;\n  }\n\n  /** Add a out stage to the aggregation pipeline */\n  out($out: number): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $out });\n    return this;\n  }\n\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **NOTE:** adding a projection changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable. Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   * ```\n   */\n  project<T = TSchema>($project: Projection<T>): AggregationCursor<T>;\n  project($project: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $project });\n    return this;\n  }\n\n  /** Add a lookup stage to the aggregation pipeline */\n  lookup($lookup: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $lookup });\n    return this;\n  }\n\n  /** Add a redact stage to the aggregation pipeline */\n  redact($redact: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $redact });\n    return this;\n  }\n\n  /** Add a skip stage to the aggregation pipeline */\n  skip($skip: number): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $skip });\n    return this;\n  }\n\n  /** Add a sort stage to the aggregation pipeline */\n  sort($sort: Sort): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $sort });\n    return this;\n  }\n\n  /** Add a unwind stage to the aggregation pipeline */\n  unwind($unwind: Document | string): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $unwind });\n    return this;\n  }\n\n  // deprecated methods\n  /** @deprecated Add a geoNear stage to the aggregation pipeline */\n  geoNear($geoNear: Document): this {\n    assertUninitialized(this);\n    this[kPipeline].push({ $geoNear });\n    return this;\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,WAAA,GAAAC,OAAA;AACA,MAAAC,iBAAA,GAAAD,OAAA;AACA,MAAAE,mBAAA,GAAAF,OAAA;AACA,MAAAG,OAAA,GAAAH,OAAA;AAcA;AACA,MAAMI,OAAO,GAAGC,MAAM,CAAC,QAAQ,CAAC;AAChC;AACA,MAAMC,SAAS,GAAGD,MAAM,CAAC,UAAU,CAAC;AACpC;AACA,MAAME,QAAQ,GAAGF,MAAM,CAAC,SAAS,CAAC;AAElC;;;;;;;AAOA,MAAaG,iBAAsC,SAAQP,iBAAA,CAAAQ,cAAuB;EAQhF;EACAC,YACEC,MAAuB,EACvBC,QAAkB,EAClBC,SAA2B,EAC3BC,QAAA,GAAuB,EAAE,EACzBC,OAAA,GAA4B,EAAE;IAE9B,KAAK,CAACH,QAAQ,EAAEC,SAAS,EAAEE,OAAO,CAAC;IAEnC,IAAI,CAACX,OAAO,CAAC,GAAGO,MAAM;IACtB,IAAI,CAACL,SAAS,CAAC,GAAGQ,QAAQ;IAC1B,IAAI,CAACP,QAAQ,CAAC,GAAGQ,OAAO;EAC1B;EAEA,IAAID,QAAQA,CAAA;IACV,OAAO,IAAI,CAACR,SAAS,CAAC;EACxB;EAEAU,KAAKA,CAAA;IACH,MAAMC,aAAa,GAAGd,OAAA,CAAAe,YAAY,CAAC,EAAE,EAAE,IAAI,CAACX,QAAQ,CAAC,CAAC;IACtD,OAAOU,aAAa,CAACE,OAAO;IAC5B,OAAO,IAAIX,iBAAiB,CAAC,IAAI,CAACJ,OAAO,CAAC,EAAE,IAAI,CAACQ,QAAQ,EAAE,IAAI,CAACC,SAAS,EAAE,IAAI,CAACP,SAAS,CAAC,EAAE;MAC1F,GAAGW;KACJ,CAAC;EACJ;EAEAG,GAAGA,CAAIC,SAA8B;IACnC,OAAO,KAAK,CAACD,GAAG,CAACC,SAAS,CAAyB;EACrD;EAEA;EACAC,WAAWA,CAACH,OAAkC,EAAEI,QAAmC;IACjF,MAAMC,kBAAkB,GAAG,IAAIzB,WAAA,CAAA0B,kBAAkB,CAAC,IAAI,CAACrB,OAAO,CAAC,EAAE,IAAI,CAACE,SAAS,CAAC,EAAE;MAChF,GAAG,IAAI,CAACC,QAAQ,CAAC;MACjB,GAAG,IAAI,CAACmB,aAAa;MACrBP;KACD,CAAC;IAEFjB,mBAAA,CAAAyB,gBAAgB,CAAC,IAAI,CAACf,QAAQ,EAAEY,kBAAkB,EAAE,CAACI,GAAG,EAAEC,QAAQ,KAAI;MACpE,IAAID,GAAG,IAAIC,QAAQ,IAAI,IAAI,EAAE,OAAON,QAAQ,CAACK,GAAG,CAAC;MAEjD;MACAL,QAAQ,CAACO,SAAS,EAAE;QAAEC,MAAM,EAAEP,kBAAkB,CAACO,MAAM;QAAEZ,OAAO;QAAEU;MAAQ,CAAE,CAAC;IAC/E,CAAC,CAAC;EACJ;EAMAG,OAAOA,CACLC,SAA2C,EAC3CV,QAA6B;IAE7B,IAAI,OAAOU,SAAS,KAAK,UAAU,EAAGV,QAAQ,GAAGU,SAAS,EAAIA,SAAS,GAAG,IAAK;IAC/E,IAAIA,SAAS,KAAKH,SAAS,EAAEG,SAAS,GAAG,IAAI;IAE7C,OAAO/B,mBAAA,CAAAyB,gBAAgB,CACrB,IAAI,CAACf,QAAQ,EACb,IAAIb,WAAA,CAAA0B,kBAAkB,CAAC,IAAI,CAACrB,OAAO,CAAC,EAAE,IAAI,CAACE,SAAS,CAAC,EAAE;MACrD,GAAG,IAAI,CAACC,QAAQ,CAAC;MACjB,GAAG,IAAI,CAACmB,aAAa;MACrBM,OAAO,EAAEC;KACV,CAAC,EACFV,QAAQ,CACT;EACH;EAIAW,KAAKA,CAACC,MAAgB;IACpBlC,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEF;IAAM,CAAE,CAAC;IAChC,OAAO,IAAI;EACb;EAEA;EACAG,KAAKA,CAACC,MAAc;IAClBtC,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEE;IAAM,CAAE,CAAC;IAChC,OAAO,IAAI;EACb;EAEA;EACAC,KAAKA,CAACC,MAAgB;IACpBxC,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEI;IAAM,CAAE,CAAC;IAChC,OAAO,IAAI;EACb;EAEA;EACAC,GAAGA,CAACC,IAAY;IACd1C,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEM;IAAI,CAAE,CAAC;IAC9B,OAAO,IAAI;EACb;EAqBAC,OAAOA,CAACC,QAAkB;IACxB5C,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEQ;IAAQ,CAAE,CAAC;IAClC,OAAO,IAAI;EACb;EAEA;EACAC,MAAMA,CAACC,OAAiB;IACtB9C,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEU;IAAO,CAAE,CAAC;IACjC,OAAO,IAAI;EACb;EAEA;EACAC,MAAMA,CAACC,OAAiB;IACtBhD,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEY;IAAO,CAAE,CAAC;IACjC,OAAO,IAAI;EACb;EAEA;EACAC,IAAIA,CAACC,KAAa;IAChBlD,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEc;IAAK,CAAE,CAAC;IAC/B,OAAO,IAAI;EACb;EAEA;EACAC,IAAIA,CAACC,KAAW;IACdpD,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEgB;IAAK,CAAE,CAAC;IAC/B,OAAO,IAAI;EACb;EAEA;EACAC,MAAMA,CAACC,OAA0B;IAC/BtD,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEkB;IAAO,CAAE,CAAC;IACjC,OAAO,IAAI;EACb;EAEA;EACA;EACAC,OAAOA,CAACC,QAAkB;IACxBxD,iBAAA,CAAAmC,mBAAmB,CAAC,IAAI,CAAC;IACzB,IAAI,CAAC9B,SAAS,CAAC,CAAC+B,IAAI,CAAC;MAAEoB;IAAQ,CAAE,CAAC;IAClC,OAAO,IAAI;EACb;;AA5KFC,OAAA,CAAAlD,iBAAA,GAAAA,iBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}