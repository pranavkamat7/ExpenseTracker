{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucket = void 0;\nconst error_1 = require(\"../error\");\nconst download_1 = require(\"./download\");\nconst upload_1 = require(\"./upload\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"../write_concern\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n  constructor(db, options) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = {\n      ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n  openUploadStream(filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, options);\n  }\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n  openUploadStreamWithId(id, filename, options) {\n    return new upload_1.GridFSBucketWriteStream(this, filename, {\n      ...options,\n      id\n    });\n  }\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n  openDownloadStream(id, options) {\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      _id: id\n    }, options);\n  }\n  delete(id, callback) {\n    return utils_1.executeLegacyOperation(utils_1.getTopology(this.s.db), _delete, [this, id, callback], {\n      skipSessions: true\n    });\n  }\n  /** Convenience wrapper around find on the files collection */\n  find(filter, options) {\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.s._filesCollection.find(filter, options);\n  }\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n  openDownloadStreamByName(filename, options) {\n    let sort = {\n      uploadDate: -1\n    };\n    let skip = undefined;\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = {\n          uploadDate: 1\n        };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n    return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, {\n      filename\n    }, {\n      ...options,\n      sort,\n      skip\n    });\n  }\n  rename(id, filename, callback) {\n    return utils_1.executeLegacyOperation(utils_1.getTopology(this.s.db), _rename, [this, id, filename, callback], {\n      skipSessions: true\n    });\n  }\n  drop(callback) {\n    return utils_1.executeLegacyOperation(utils_1.getTopology(this.s.db), _drop, [this, callback], {\n      skipSessions: true\n    });\n  }\n  /** Get the Db scoped logger. */\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n}\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\nGridFSBucket.INDEX = 'index';\nfunction _delete(bucket, id, callback) {\n  return bucket.s._filesCollection.deleteOne({\n    _id: id\n  }, (error, res) => {\n    if (error) {\n      return callback(error);\n    }\n    return bucket.s._chunksCollection.deleteMany({\n      files_id: id\n    }, error => {\n      if (error) {\n        return callback(error);\n      }\n      // Delete orphaned chunks before returning FileNotFound\n      if (!(res === null || res === void 0 ? void 0 : res.deletedCount)) {\n        const errmsg = 'FileNotFound: no file with id ' + id + ' found';\n        return callback(new error_1.MongoDriverError(errmsg));\n      }\n      return callback();\n    });\n  });\n}\nfunction _rename(bucket, id, filename, callback) {\n  const filter = {\n    _id: id\n  };\n  const update = {\n    $set: {\n      filename\n    }\n  };\n  return bucket.s._filesCollection.updateOne(filter, update, (error, res) => {\n    if (error) {\n      return callback(error);\n    }\n    if (!(res === null || res === void 0 ? void 0 : res.matchedCount)) {\n      return callback(new error_1.MongoDriverError(`File with id ${id} not found`));\n    }\n    return callback();\n  });\n}\nfunction _drop(bucket, callback) {\n  return bucket.s._filesCollection.drop(error => {\n    if (error) {\n      return callback(error);\n    }\n    return bucket.s._chunksCollection.drop(error => {\n      if (error) {\n        return callback(error);\n      }\n      return callback();\n    });\n  });\n}","map":{"version":3,"names":["error_1","require","download_1","upload_1","utils_1","write_concern_1","mongo_types_1","DEFAULT_GRIDFS_BUCKET_OPTIONS","bucketName","chunkSizeBytes","GridFSBucket","TypedEventEmitter","constructor","db","options","setMaxListeners","privateOptions","writeConcern","WriteConcern","fromOptions","s","_chunksCollection","collection","_filesCollection","checkedIndexes","calledOpenUploadStream","openUploadStream","filename","GridFSBucketWriteStream","openUploadStreamWithId","id","openDownloadStream","GridFSBucketReadStream","readPreference","_id","delete","callback","executeLegacyOperation","getTopology","_delete","skipSessions","find","filter","openDownloadStreamByName","sort","uploadDate","skip","undefined","revision","rename","_rename","drop","_drop","getLogger","logger","exports","INDEX","bucket","deleteOne","error","res","deleteMany","files_id","deletedCount","errmsg","MongoDriverError","update","$set","updateOne","matchedCount"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\gridfs\\index.ts"],"sourcesContent":["import { MongoDriverError } from '../error';\nimport {\n  GridFSBucketReadStream,\n  GridFSBucketReadStreamOptions,\n  GridFSBucketReadStreamOptionsWithRevision,\n  GridFSFile\n} from './download';\nimport { GridFSBucketWriteStream, GridFSBucketWriteStreamOptions, GridFSChunk } from './upload';\nimport { executeLegacyOperation, Callback, getTopology } from '../utils';\nimport { WriteConcernOptions, WriteConcern } from '../write_concern';\nimport type { ObjectId } from '../bson';\nimport type { Db } from '../db';\nimport type { ReadPreference } from '../read_preference';\nimport type { Collection } from '../collection';\nimport type { FindOptions } from './../operations/find';\nimport type { Sort } from '../sort';\nimport type { Logger } from '../logger';\nimport type { FindCursor } from '../cursor/find_cursor';\nimport { Filter, TypedEventEmitter } from '../mongo_types';\n\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS: {\n  bucketName: string;\n  chunkSizeBytes: number;\n} = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n\n/** @public */\nexport interface GridFSBucketOptions extends WriteConcernOptions {\n  /** The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot. */\n  bucketName?: string;\n  /** Number of bytes stored in each chunk. Defaults to 255KB */\n  chunkSizeBytes?: number;\n  /** Read preference to be passed to read operations */\n  readPreference?: ReadPreference;\n}\n\n/** @internal */\nexport interface GridFSBucketPrivate {\n  db: Db;\n  options: {\n    bucketName: string;\n    chunkSizeBytes: number;\n    readPreference?: ReadPreference;\n    writeConcern: WriteConcern | undefined;\n  };\n  _chunksCollection: Collection<GridFSChunk>;\n  _filesCollection: Collection<GridFSFile>;\n  checkedIndexes: boolean;\n  calledOpenUploadStream: boolean;\n}\n\n/** @public */\nexport type GridFSBucketEvents = {\n  index(): void;\n};\n\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nexport class GridFSBucket extends TypedEventEmitter<GridFSBucketEvents> {\n  /** @internal */\n  s: GridFSBucketPrivate;\n\n  /**\n   * When the first call to openUploadStream is made, the upload stream will\n   * check to see if it needs to create the proper indexes on the chunks and\n   * files collections. This event is fired either when 1) it determines that\n   * no index creation is necessary, 2) when it successfully creates the\n   * necessary indexes.\n   * @event\n   */\n  static readonly INDEX = 'index' as const;\n\n  constructor(db: Db, options?: GridFSBucketOptions) {\n    super();\n    this.setMaxListeners(0);\n    const privateOptions = {\n      ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n      ...options,\n      writeConcern: WriteConcern.fromOptions(options)\n    };\n    this.s = {\n      db,\n      options: privateOptions,\n      _chunksCollection: db.collection<GridFSChunk>(privateOptions.bucketName + '.chunks'),\n      _filesCollection: db.collection<GridFSFile>(privateOptions.bucketName + '.files'),\n      checkedIndexes: false,\n      calledOpenUploadStream: false\n    };\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS. The stream's 'id' property contains the resulting\n   * file's id.\n   *\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n\n  openUploadStream(\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, options);\n  }\n\n  /**\n   * Returns a writable stream (GridFSBucketWriteStream) for writing\n   * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n   * file's id.\n   */\n  openUploadStreamWithId(\n    id: ObjectId,\n    filename: string,\n    options?: GridFSBucketWriteStreamOptions\n  ): GridFSBucketWriteStream {\n    return new GridFSBucketWriteStream(this, filename, { ...options, id });\n  }\n\n  /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n  openDownloadStream(\n    id: ObjectId,\n    options?: GridFSBucketReadStreamOptions\n  ): GridFSBucketReadStream {\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { _id: id },\n      options\n    );\n  }\n\n  /**\n   * Deletes a file with the given id\n   *\n   * @param id - The id of the file doc\n   */\n  delete(id: ObjectId): Promise<undefined>;\n  delete(id: ObjectId, callback: Callback<void>): void;\n  delete(id: ObjectId, callback?: Callback<void>): Promise<undefined> | void {\n    return executeLegacyOperation(getTopology(this.s.db), _delete, [this, id, callback], {\n      skipSessions: true\n    });\n  }\n\n  /** Convenience wrapper around find on the files collection */\n  find(filter?: Filter<GridFSFile>, options?: FindOptions): FindCursor<GridFSFile> {\n    filter ??= {};\n    options = options ?? {};\n    return this.s._filesCollection.find(filter, options);\n  }\n\n  /**\n   * Returns a readable stream (GridFSBucketReadStream) for streaming the\n   * file with the given name from GridFS. If there are multiple files with\n   * the same name, this will stream the most recent file with the given name\n   * (as determined by the `uploadDate` field). You can set the `revision`\n   * option to change this behavior.\n   */\n  openDownloadStreamByName(\n    filename: string,\n    options?: GridFSBucketReadStreamOptionsWithRevision\n  ): GridFSBucketReadStream {\n    let sort: Sort = { uploadDate: -1 };\n    let skip = undefined;\n    if (options && options.revision != null) {\n      if (options.revision >= 0) {\n        sort = { uploadDate: 1 };\n        skip = options.revision;\n      } else {\n        skip = -options.revision - 1;\n      }\n    }\n    return new GridFSBucketReadStream(\n      this.s._chunksCollection,\n      this.s._filesCollection,\n      this.s.options.readPreference,\n      { filename },\n      { ...options, sort, skip }\n    );\n  }\n\n  /**\n   * Renames the file with the given _id to the given string\n   *\n   * @param id - the id of the file to rename\n   * @param filename - new name for the file\n   */\n  rename(id: ObjectId, filename: string): Promise<void>;\n  rename(id: ObjectId, filename: string, callback: Callback<void>): void;\n  rename(id: ObjectId, filename: string, callback?: Callback<void>): Promise<void> | void {\n    return executeLegacyOperation(getTopology(this.s.db), _rename, [this, id, filename, callback], {\n      skipSessions: true\n    });\n  }\n\n  /** Removes this bucket's files collection, followed by its chunks collection. */\n  drop(): Promise<void>;\n  drop(callback: Callback<void>): void;\n  drop(callback?: Callback<void>): Promise<void> | void {\n    return executeLegacyOperation(getTopology(this.s.db), _drop, [this, callback], {\n      skipSessions: true\n    });\n  }\n\n  /** Get the Db scoped logger. */\n  getLogger(): Logger {\n    return this.s.db.s.logger;\n  }\n}\n\nfunction _delete(bucket: GridFSBucket, id: ObjectId, callback: Callback<void>): void {\n  return bucket.s._filesCollection.deleteOne({ _id: id }, (error, res) => {\n    if (error) {\n      return callback(error);\n    }\n\n    return bucket.s._chunksCollection.deleteMany({ files_id: id }, error => {\n      if (error) {\n        return callback(error);\n      }\n\n      // Delete orphaned chunks before returning FileNotFound\n      if (!res?.deletedCount) {\n        const errmsg = 'FileNotFound: no file with id ' + id + ' found';\n        return callback(new MongoDriverError(errmsg));\n      }\n\n      return callback();\n    });\n  });\n}\n\nfunction _rename(\n  bucket: GridFSBucket,\n  id: ObjectId,\n  filename: string,\n  callback: Callback<void>\n): void {\n  const filter = { _id: id };\n  const update = { $set: { filename } };\n  return bucket.s._filesCollection.updateOne(filter, update, (error?, res?) => {\n    if (error) {\n      return callback(error);\n    }\n\n    if (!res?.matchedCount) {\n      return callback(new MongoDriverError(`File with id ${id} not found`));\n    }\n\n    return callback();\n  });\n}\n\nfunction _drop(bucket: GridFSBucket, callback: Callback<void>): void {\n  return bucket.s._filesCollection.drop((error?: Error) => {\n    if (error) {\n      return callback(error);\n    }\n    return bucket.s._chunksCollection.drop((error?: Error) => {\n      if (error) {\n        return callback(error);\n      }\n\n      return callback();\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}