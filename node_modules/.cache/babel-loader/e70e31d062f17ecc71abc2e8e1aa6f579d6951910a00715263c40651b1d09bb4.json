{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoConnection = exports.APM_EVENTS = exports.Connection = void 0;\nconst message_stream_1 = require(\"./message_stream\");\nconst stream_description_1 = require(\"./stream_description\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst error_1 = require(\"../error\");\nconst commands_1 = require(\"./commands\");\nconst bson_1 = require(\"../bson\");\nconst shared_1 = require(\"./wire_protocol/shared\");\nconst read_preference_1 = require(\"../read_preference\");\nconst transactions_1 = require(\"../transactions\");\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kIsMaster = Symbol('ismaster');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = utils_1.now();\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({\n      ...options,\n      maxBsonMessageSize: (_b = this.ismaster) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    this[kMessageStream].on('error', error => this.handleIssue({\n      destroy: error\n    }));\n    stream.on('close', () => this.handleIssue({\n      isClose: true\n    }));\n    stream.on('timeout', () => this.handleIssue({\n      isTimeout: true,\n      destroy: true\n    }));\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n  get description() {\n    return this[kDescription];\n  }\n  get ismaster() {\n    return this[kIsMaster];\n  }\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n  get idleTime() {\n    return utils_1.calculateDurationInMs(this[kLastUseTime]);\n  }\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n  get stream() {\n    return this[kStream];\n  }\n  markAvailable() {\n    this[kLastUseTime] = utils_1.now();\n  }\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n    this.closed = true;\n    for (const [, op] of this[kQueue]) {\n      if (issue.isTimeout) {\n        op.cb(new error_1.MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n          beforeHandshake: this.ismaster == null\n        }));\n      } else if (issue.isClose) {\n        op.cb(new error_1.MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n    options = Object.assign({\n      force: false\n    }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    this[kStream].end(() => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n  /** @internal */\n  command(ns, cmd, options, callback) {\n    if (typeof ns.db === 'undefined' || typeof ns === 'string') {\n      throw new error_1.MongoDriverError('ns cannot be a string');\n    }\n    const readPreference = shared_1.getReadPreference(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n    const inTransaction = session && (session.inTransaction() || transactions_1.isTransactionCommand(finalCmd));\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n      // We need to unpin any read or write commands that happen outside of a pinned\n      // transaction, so we check if we have a pinned transaction that is no longer\n      // active, and unpin for all except start or commit.\n      if (!session.transaction.isActive && session.transaction.isPinned && !finalCmd.startTransaction && !finalCmd.commitTransaction) {\n        session.transaction.unpinServer();\n      }\n      const err = sessions_1.applySession(session, finalCmd, options);\n      if (err) {\n        return callback(err);\n      }\n    }\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n    if (shared_1.isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      slaveOk: readPreference.slaveOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n    const commandResponseHandler = inTransaction ? (err, ...args) => {\n      // We need to add a TransientTransactionError errorLabel, as stated in the transaction spec.\n      if (err && err instanceof error_1.MongoNetworkError && !err.hasErrorLabel('TransientTransactionError')) {\n        err.addErrorLabel('TransientTransactionError');\n      }\n      if (session && !cmd.commitTransaction && err && err instanceof error_1.MongoError && err.hasErrorLabel('TransientTransactionError')) {\n        session.transaction.unpinServer();\n      }\n      return callback(err, ...args);\n    } : callback;\n    try {\n      write(this, message, commandOptions, commandResponseHandler);\n    } catch (err) {\n      commandResponseHandler(err);\n    }\n  }\n  /** @internal */\n  query(ns, cmd, options, callback) {\n    var _a;\n    const isExplain = typeof cmd.$explain !== 'undefined';\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n    if (limit && (limit < 0 || limit !== 0 && limit < batchSize || limit > 0 && batchSize === 0)) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n    const queryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      slaveOk: readPreference.slaveOk()\n    };\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n    const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n    write(this, query, {\n      fullResult: true,\n      ...bson_1.pluckBSONSerializeOptions(options)\n    }, (err, result) => {\n      if (err || !result) return callback(err, result);\n      if (isExplain && result.documents && result.documents[0]) {\n        return callback(undefined, result.documents[0]);\n      }\n      callback(undefined, result);\n    });\n  }\n  /** @internal */\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n    const wireVersion = utils_1.maxWireVersion(this);\n    if (!cursorId) {\n      callback(new error_1.MongoDriverError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = shared_1.applyCommonQueryOptions({}, Object.assign(options, {\n        ...bson_1.pluckBSONSerializeOptions(options)\n      }));\n      queryOptions.fullResult = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n  /** @internal */\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      throw new error_1.MongoDriverError('Invalid list of cursor ids provided: ' + cursorIds);\n    }\n    if (utils_1.maxWireVersion(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n      return;\n    }\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      fullResult: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback(new error_1.MongoDriverError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n      callback(undefined, response.documents[0]);\n    });\n  }\n}\nexports.Connection = Connection;\n/** @event */\nConnection.COMMAND_STARTED = 'commandStarted';\n/** @event */\nConnection.COMMAND_SUCCEEDED = 'commandSucceeded';\n/** @event */\nConnection.COMMAND_FAILED = 'commandFailed';\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';\n/** @event */\nConnection.CLOSE = 'close';\n/** @event */\nConnection.MESSAGE = 'message';\n/** @public */\nexports.APM_EVENTS = [Connection.COMMAND_STARTED, Connection.COMMAND_SUCCEEDED, Connection.COMMAND_FAILED];\n/** @internal */\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoDriverError('No AutoEncrypter available for encryption'));\n    }\n    const serverWireVersion = utils_1.maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoDriverError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\nexports.CryptoConnection = CryptoConnection;\nfunction hasSessionSupport(conn) {\n  return conn.description.logicalSessionTimeoutMinutes != null;\n}\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n  return utils_1.maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    if (!operationDescription) {\n      return;\n    }\n    const callback = operationDescription.cb;\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeoutMS);\n    }\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        sessions_1.updateSessionFromResponse(session, document);\n      }\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  };\n}\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n  return utils_1.uuidV4().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  }\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = utils_1.now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"names":["message_stream_1","require","stream_description_1","command_monitoring_events_1","sessions_1","utils_1","error_1","commands_1","bson_1","shared_1","read_preference_1","transactions_1","mongo_types_1","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","Connection","TypedEventEmitter","constructor","stream","options","id","address","streamIdentifier","socketTimeoutMS","_a","monitorCommands","serverApi","closed","destroyed","StreamDescription","generation","now","Map","MessageStream","maxBsonMessageSize","_b","ismaster","on","messageHandler","error","handleIssue","destroy","isClose","isTimeout","pipe","description","response","receiveResponse","Object","freeze","idleTime","calculateDurationInMs","clusterTime","markAvailable","issue","undefined","op","cb","MongoNetworkTimeoutError","beforeHandshake","MongoNetworkError","clear","emit","CLOSE","callback","force","assign","end","command","ns","cmd","db","MongoDriverError","readPreference","getReadPreference","shouldUseOpMsg","supportsOpMsg","session","finalCmd","inTransaction","isTransactionCommand","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","transaction","isActive","isPinned","startTransaction","commitTransaction","unpinServer","err","applySession","$clusterTime","isSharded","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","slaveOk","cmdNs","message","Msg","Query","commandResponseHandler","args","hasErrorLabel","addErrorLabel","MongoError","write","query","isExplain","$explain","ReadPreference","primary","batchSize","limit","skip","Math","abs","queryOptions","pre32Limit","projection","returnFieldSelector","toString","tailable","oplogReplay","timeout","noCursorTimeout","awaitData","partial","fullResult","pluckBSONSerializeOptions","result","documents","getMore","cursorId","wireVersion","maxWireVersion","getMoreOp","GetMore","applyCommonQueryOptions","cursor","nextBatch","getMoreCmd","collection","maxAwaitTimeMS","maxTimeMS","documentsReturnedIn","killCursors","cursorIds","Array","isArray","KillCursor","noResponse","cursors","cursorNotFound","length","exports","COMMAND_STARTED","COMMAND_SUCCEEDED","COMMAND_FAILED","CLUSTER_TIME_RECEIVED","MESSAGE","APM_EVENTS","CryptoConnection","autoEncrypter","serverWireVersion","encrypt","encrypted","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","operationDescription","get","responseTo","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","document","updateSessionFromResponse","writeConcernError","MongoWriteConcernError","ok","$err","errmsg","code","MongoServerError","remoteAddress","remotePort","uuidV4","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","raw","started","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","reply","CommandFailedEvent","CommandSucceededEvent","writeCommand","e"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\cmap\\connection.ts"],"sourcesContent":["import { MessageStream, OperationDescription } from './message_stream';\nimport { StreamDescription, StreamDescriptionOptions } from './stream_description';\nimport {\n  CommandStartedEvent,\n  CommandFailedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport { applySession, ClientSession, updateSessionFromResponse } from '../sessions';\nimport {\n  uuidV4,\n  ClientMetadata,\n  now,\n  calculateDurationInMs,\n  Callback,\n  MongoDBNamespace,\n  maxWireVersion,\n  HostAddress\n} from '../utils';\nimport {\n  AnyError,\n  MongoDriverError,\n  MongoError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoServerError,\n  MongoWriteConcernError\n} from '../error';\nimport {\n  BinMsg,\n  WriteProtocolMessageType,\n  Response,\n  KillCursor,\n  GetMore,\n  Query,\n  OpQueryOptions,\n  Msg\n} from './commands';\nimport { BSONSerializeOptions, Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport type { AutoEncrypter } from '../deps';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport type { Stream } from './connect';\nimport { applyCommonQueryOptions, getReadPreference, isSharded } from './wire_protocol/shared';\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\nimport { isTransactionCommand } from '../transactions';\nimport type { W, WriteConcern, WriteConcernOptions } from '../write_concern';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\n\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kIsMaster = Symbol('ismaster');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\n/** @internal */\nexport interface QueryOptions extends BSONSerializeOptions {\n  readPreference: ReadPreference;\n  documentsReturnedIn?: string;\n  batchSize?: number;\n  limit?: number;\n  skip?: number;\n  projection?: Document;\n  tailable?: boolean;\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** @deprecated use `noCursorTimeout` instead */\n  timeout?: boolean;\n  partial?: boolean;\n  oplogReplay?: boolean;\n}\n\n/** @public */\nexport interface CommandOptions extends BSONSerializeOptions {\n  command?: boolean;\n  slaveOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  raw?: boolean;\n  monitoring?: boolean;\n  fullResult?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n\n  // FIXME: NODE-2802\n  willRetryWrite?: boolean;\n\n  // FIXME: NODE-2781\n  writeConcern?: WriteConcernOptions | WriteConcern | W;\n}\n\n/** @internal */\nexport interface GetMoreOptions extends CommandOptions {\n  batchSize?: number;\n  maxTimeMS?: number;\n  maxAwaitTimeMS?: number;\n  comment?: Document | string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  // Settings\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: typeof Connection;\n  credentials?: MongoCredentials;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  keepAlive?: boolean;\n  keepAliveInitialDelay?: number;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n\n  metadata: ClientMetadata;\n}\n\n/** @public */\nexport interface DestroyOptions {\n  /** Force the destruction. */\n  force?: boolean;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  message(message: any): void;\n};\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  id: number | '<monitor>';\n  address: string;\n  socketTimeoutMS: number;\n  monitorCommands: boolean;\n  closed: boolean;\n  destroyed: boolean;\n  lastIsMasterMS?: number;\n  serverApi?: ServerApi;\n  helloOk?: boolean;\n  /** @internal */\n  [kDescription]: StreamDescription;\n  /** @internal */\n  [kGeneration]: number;\n  /** @internal */\n  [kLastUseTime]: number;\n  /** @internal */\n  [kQueue]: Map<number, OperationDescription>;\n  /** @internal */\n  [kMessageStream]: MessageStream;\n  /** @internal */\n  [kStream]: Stream;\n  /** @internal */\n  [kIsMaster]: Document;\n  /** @internal */\n  [kClusterTime]: Document;\n\n  /** @event */\n  static readonly COMMAND_STARTED = 'commandStarted' as const;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = 'commandSucceeded' as const;\n  /** @event */\n  static readonly COMMAND_FAILED = 'commandFailed' as const;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = 'clusterTimeReceived' as const;\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n  /** @event */\n  static readonly MESSAGE = 'message' as const;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream({\n      ...options,\n      maxBsonMessageSize: this.ismaster?.maxBsonMessageSize\n    });\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    this[kMessageStream].on('error', error => this.handleIssue({ destroy: error }));\n    stream.on('close', () => this.handleIssue({ isClose: true }));\n    stream.on('timeout', () => this.handleIssue({ isTimeout: true, destroy: true }));\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description(): StreamDescription {\n    return this[kDescription];\n  }\n\n  get ismaster(): Document {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response: Document) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n\n  get generation(): number {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime(): number {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime(): Document {\n    return this[kClusterTime];\n  }\n\n  get stream(): Stream {\n    return this[kStream];\n  }\n\n  markAvailable(): void {\n    this[kLastUseTime] = now();\n  }\n\n  handleIssue(issue: { isTimeout?: boolean; isClose?: boolean; destroy?: boolean | Error }): void {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const [, op] of this[kQueue]) {\n      if (issue.isTimeout) {\n        op.cb(\n          new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n            beforeHandshake: this.ismaster == null\n          })\n        );\n      } else if (issue.isClose) {\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  destroy(): void;\n  destroy(callback: Callback): void;\n  destroy(options: DestroyOptions): void;\n  destroy(options: DestroyOptions, callback: Callback): void;\n  destroy(options?: DestroyOptions | Callback, callback?: Callback): void {\n    if (typeof options === 'function') {\n      callback = options;\n      options = { force: false };\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  /** @internal */\n  command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions | undefined,\n    callback: Callback\n  ): void {\n    if (typeof ns.db === 'undefined' || typeof ns === 'string') {\n      throw new MongoDriverError('ns cannot be a string');\n    }\n\n    const readPreference = getReadPreference(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n    const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      // We need to unpin any read or write commands that happen outside of a pinned\n      // transaction, so we check if we have a pinned transaction that is no longer\n      // active, and unpin for all except start or commit.\n      if (\n        !session.transaction.isActive &&\n        session.transaction.isPinned &&\n        !finalCmd.startTransaction &&\n        !finalCmd.commitTransaction\n      ) {\n        session.transaction.unpinServer();\n      }\n\n      const err = applySession(session, finalCmd, options as CommandOptions);\n      if (err) {\n        return callback(err);\n      }\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions: Document = Object.assign(\n      {\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        slaveOk: readPreference.slaveOk()\n      },\n      options\n    );\n\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg\n      ? new Msg(cmdNs, finalCmd, commandOptions)\n      : new Query(cmdNs, finalCmd, commandOptions);\n\n    const commandResponseHandler = inTransaction\n      ? (err?: AnyError, ...args: Document[]) => {\n          // We need to add a TransientTransactionError errorLabel, as stated in the transaction spec.\n          if (\n            err &&\n            err instanceof MongoNetworkError &&\n            !err.hasErrorLabel('TransientTransactionError')\n          ) {\n            err.addErrorLabel('TransientTransactionError');\n          }\n\n          if (\n            session &&\n            !cmd.commitTransaction &&\n            err &&\n            err instanceof MongoError &&\n            err.hasErrorLabel('TransientTransactionError')\n          ) {\n            session.transaction.unpinServer();\n          }\n\n          return callback(err, ...args);\n        }\n      : callback;\n\n    try {\n      write(this, message, commandOptions, commandResponseHandler);\n    } catch (err) {\n      commandResponseHandler(err);\n    }\n  }\n\n  /** @internal */\n  query(ns: MongoDBNamespace, cmd: Document, options: QueryOptions, callback: Callback): void {\n    const isExplain = typeof cmd.$explain !== 'undefined';\n    const readPreference = options.readPreference ?? ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n    if (\n      limit &&\n      (limit < 0 || (limit !== 0 && limit < batchSize) || (limit > 0 && batchSize === 0))\n    ) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions: OpQueryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      slaveOk: readPreference.slaveOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new Query(ns.toString(), cmd, queryOptions);\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(\n      this,\n      query,\n      { fullResult: true, ...pluckBSONSerializeOptions(options) },\n      (err, result) => {\n        if (err || !result) return callback(err, result);\n        if (isExplain && result.documents && result.documents[0]) {\n          return callback(undefined, result.documents[0]);\n        }\n\n        callback(undefined, result);\n      }\n    );\n  }\n\n  /** @internal */\n  getMore(\n    ns: MongoDBNamespace,\n    cursorId: Long,\n    options: GetMoreOptions,\n    callback: Callback<Document>\n  ): void {\n    const fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n    const wireVersion = maxWireVersion(this);\n    if (!cursorId) {\n      callback(new MongoDriverError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new GetMore(ns.toString(), cursorId, { numberToReturn: options.batchSize });\n      const queryOptions = applyCommonQueryOptions(\n        {},\n        Object.assign(options, { ...pluckBSONSerializeOptions(options) })\n      );\n\n      queryOptions.fullResult = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, { cursor: { id: response.cursorId, nextBatch: response.documents } });\n      });\n\n      return;\n    }\n\n    const getMoreCmd: Document = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n\n    const commandOptions = Object.assign(\n      {\n        returnFieldSelector: null,\n        documentsReturnedIn: 'nextBatch'\n      },\n      options\n    );\n\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n\n  /** @internal */\n  killCursors(\n    ns: MongoDBNamespace,\n    cursorIds: Long[],\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      throw new MongoDriverError('Invalid list of cursor ids provided: ' + cursorIds);\n    }\n\n    if (maxWireVersion(this) < 4) {\n      try {\n        write(\n          this,\n          new KillCursor(ns.toString(), cursorIds),\n          { noResponse: true, ...options },\n          callback\n        );\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(\n      ns,\n      { killCursors: ns.collection, cursors: cursorIds },\n      { fullResult: true, ...options },\n      (err, response) => {\n        if (err || !response) return callback(err);\n        if (response.cursorNotFound) {\n          return callback(new MongoNetworkError('cursor killed or timed out'), null);\n        }\n\n        if (!Array.isArray(response.documents) || response.documents.length === 0) {\n          return callback(\n            new MongoDriverError(\n              `invalid killCursors result returned for cursor id ${cursorIds[0]}`\n            )\n          );\n        }\n\n        callback(undefined, response.documents[0]);\n      }\n    );\n  }\n}\n\n/** @public */\nexport const APM_EVENTS = [\n  Connection.COMMAND_STARTED,\n  Connection.COMMAND_SUCCEEDED,\n  Connection.COMMAND_FAILED\n];\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  [kAutoEncrypter]?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n\n  /** @internal @override */\n  command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions, callback: Callback): void {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new MongoDriverError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new MongoDriverError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\n\nfunction hasSessionSupport(conn: Connection) {\n  return conn.description.logicalSessionTimeoutMinutes != null;\n}\n\nfunction supportsOpMsg(conn: Connection) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction messageHandler(conn: Connection) {\n  return function messageHandler(message: BinMsg | Response) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document: Document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  };\n}\n\nfunction streamIdentifier(stream: Stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\nfunction write(\n  conn: Connection,\n  command: WriteProtocolMessageType,\n  options: CommandOptions,\n  callback: Callback\n) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options ?? {};\n  const operationDescription: OperationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(\n          Connection.COMMAND_FAILED,\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(\n            Connection.COMMAND_FAILED,\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\n          );\n        } else {\n          conn.emit(\n            Connection.COMMAND_SUCCEEDED,\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}