{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HEARTBEAT_EVENTS = exports.Server = void 0;\nconst logger_1 = require(\"../logger\");\nconst connection_pool_1 = require(\"../cmap/connection_pool\");\nconst server_description_1 = require(\"./server_description\");\nconst monitor_1 = require(\"./monitor\");\nconst transactions_1 = require(\"../transactions\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nconst error_1 = require(\"../error\");\nconst connection_1 = require(\"../cmap/connection\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst stateTransition = utils_1.makeStateMachine({\n  [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],\n  [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],\n  [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],\n  [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]\n});\n/** @internal */\nconst kMonitor = Symbol('monitor');\n/** @internal */\nclass Server extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a server\n   */\n  constructor(topology, description, options) {\n    super();\n    this.serverApi = options.serverApi;\n    const poolOptions = {\n      hostAddress: description.hostAddress,\n      ...options\n    };\n    this.s = {\n      description,\n      options,\n      logger: new logger_1.Logger('Server'),\n      state: common_1.STATE_CLOSED,\n      topology,\n      pool: new connection_pool_1.ConnectionPool(poolOptions)\n    };\n    for (const event of [...connection_pool_1.CMAP_EVENTS, ...connection_1.APM_EVENTS]) {\n      this.s.pool.on(event, e => this.emit(event, e));\n    }\n    this.s.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, clusterTime => {\n      this.clusterTime = clusterTime;\n    });\n    // create the monitor\n    this[kMonitor] = new monitor_1.Monitor(this, this.s.options);\n    for (const event of exports.HEARTBEAT_EVENTS) {\n      this[kMonitor].on(event, e => this.emit(event, e));\n    }\n    this[kMonitor].on('resetConnectionPool', () => {\n      this.s.pool.clear();\n    });\n    this[kMonitor].on('resetServer', error => markServerUnknown(this, error));\n    this[kMonitor].on(Server.SERVER_HEARTBEAT_SUCCEEDED, event => {\n      this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {\n        roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)\n      }));\n      if (this.s.state === common_1.STATE_CONNECTING) {\n        stateTransition(this, common_1.STATE_CONNECTED);\n        this.emit(Server.CONNECT, this);\n      }\n    });\n  }\n  get description() {\n    return this.s.description;\n  }\n  get name() {\n    return this.s.description.address;\n  }\n  get autoEncrypter() {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n  }\n  /**\n   * Initiate server connect\n   */\n  connect() {\n    if (this.s.state !== common_1.STATE_CLOSED) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CONNECTING);\n    this[kMonitor].connect();\n  }\n  /** Destroy the server connection */\n  destroy(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = Object.assign({}, {\n      force: false\n    }, options);\n    if (this.s.state === common_1.STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    this[kMonitor].close();\n    this.s.pool.close(options, err => {\n      stateTransition(this, common_1.STATE_CLOSED);\n      this.emit('closed');\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n  requestCheck() {\n    this[kMonitor].requestCheck();\n  }\n  command(ns, cmd, options, callback) {\n    if (typeof options === 'function') {\n      callback = options, options = {}, options = options !== null && options !== void 0 ? options : {};\n    }\n    if (callback == null) {\n      throw new error_1.MongoDriverError('callback must be provided');\n    }\n    if (ns.db == null || typeof ns === 'string') {\n      throw new error_1.MongoDriverError('ns must not be a string');\n    }\n    if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {\n      callback(new error_1.MongoDriverError('server is closed'));\n      return;\n    }\n    // Clone the options\n    const finalOptions = Object.assign({}, options, {\n      wireProtocolCommand: false\n    });\n    // error if collation not supported\n    if (utils_1.collationNotSupported(this, cmd)) {\n      callback(new error_1.MongoDriverError(`server ${this.name} does not support collation`));\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.command(ns, cmd, finalOptions, makeOperationHandler(this, conn, cmd, finalOptions, cb));\n    }, callback);\n  }\n  /**\n   * Execute a query against the server\n   * @internal\n   */\n  query(ns, cmd, options, callback) {\n    if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {\n      callback(new error_1.MongoDriverError('server is closed'));\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.query(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));\n    }, callback);\n  }\n  /**\n   * Execute a `getMore` against the server\n   * @internal\n   */\n  getMore(ns, cursorId, options, callback) {\n    if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {\n      callback(new error_1.MongoDriverError('server is closed'));\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.getMore(ns, cursorId, options, makeOperationHandler(this, conn, {}, options, cb));\n    }, callback);\n  }\n  /**\n   * Execute a `killCursors` command against the server\n   * @internal\n   */\n  killCursors(ns, cursorIds, options, callback) {\n    if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new error_1.MongoDriverError('server is closed'));\n      }\n      return;\n    }\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n      conn.killCursors(ns, cursorIds, options, makeOperationHandler(this, conn, {}, undefined, cb));\n    }, callback);\n  }\n}\nexports.Server = Server;\n/** @event */\nServer.SERVER_HEARTBEAT_STARTED = 'serverHeartbeatStarted';\n/** @event */\nServer.SERVER_HEARTBEAT_SUCCEEDED = 'serverHeartbeatSucceeded';\n/** @event */\nServer.SERVER_HEARTBEAT_FAILED = 'serverHeartbeatFailed';\n/** @event */\nServer.CONNECT = 'connect';\n/** @event */\nServer.DESCRIPTION_RECEIVED = 'descriptionReceived';\n/** @event */\nServer.CLOSED = 'closed';\n/** @event */\nServer.ENDED = 'ended';\nexports.HEARTBEAT_EVENTS = [Server.SERVER_HEARTBEAT_STARTED, Server.SERVER_HEARTBEAT_SUCCEEDED, Server.SERVER_HEARTBEAT_FAILED];\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get() {\n    return this.s.topology.clusterTime;\n  },\n  set(clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\nfunction supportsRetryableWrites(server) {\n  return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== common_1.ServerType.Standalone;\n}\nfunction calculateRoundTripTime(oldRtt, duration) {\n  if (oldRtt === -1) {\n    return duration;\n  }\n  const alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\nfunction markServerUnknown(server, error) {\n  if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {\n    server[kMonitor].reset();\n  }\n  server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, {\n    error,\n    topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion\n  }));\n}\nfunction connectionIsStale(pool, connection) {\n  return connection.generation !== pool.generation;\n}\nfunction shouldHandleStateChangeError(server, err) {\n  const etv = err.topologyVersion;\n  const stv = server.description.topologyVersion;\n  return server_description_1.compareTopologyVersion(stv, etv) < 0;\n}\nfunction inActiveTransaction(session, cmd) {\n  return session && session.inTransaction() && !transactions_1.isTransactionCommand(cmd);\n}\n/** this checks the retryWrites option passed down from the client options, it\n * does not check if the server supports retryable writes */\nfunction isRetryableWritesEnabled(topology) {\n  return topology.s.options.retryWrites !== false;\n}\nfunction makeOperationHandler(server, connection, cmd, options, callback) {\n  const session = options === null || options === void 0 ? void 0 : options.session;\n  return function handleOperationResult(err, result) {\n    if (err && !connectionIsStale(server.s.pool, connection)) {\n      if (err instanceof error_1.MongoNetworkError) {\n        if (session && !session.hasEnded && session.serverSession) {\n          session.serverSession.isDirty = true;\n        }\n        if ((isRetryableWritesEnabled(server.s.topology) || transactions_1.isTransactionCommand(cmd)) && supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n        if (!(err instanceof error_1.MongoNetworkTimeoutError) || error_1.isNetworkErrorBeforeHandshake(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else {\n        // if pre-4.4 server, then add error label if its a retryable write error\n        if ((isRetryableWritesEnabled(server.s.topology) || transactions_1.isTransactionCommand(cmd)) && utils_1.maxWireVersion(server) < 9 && error_1.isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n        if (error_1.isSDAMUnrecoverableError(err)) {\n          if (shouldHandleStateChangeError(server, err)) {\n            if (utils_1.maxWireVersion(server) <= 7 || error_1.isNodeShuttingDownError(err)) {\n              server.s.pool.clear();\n            }\n            markServerUnknown(server, err);\n            process.nextTick(() => server.requestCheck());\n          }\n        }\n      }\n    }\n    callback(err, result);\n  };\n}","map":{"version":3,"names":["logger_1","require","connection_pool_1","server_description_1","monitor_1","transactions_1","utils_1","common_1","error_1","connection_1","mongo_types_1","stateTransition","makeStateMachine","STATE_CLOSED","STATE_CONNECTING","STATE_CLOSING","STATE_CONNECTED","kMonitor","Symbol","Server","TypedEventEmitter","constructor","topology","description","options","serverApi","poolOptions","hostAddress","s","logger","Logger","state","pool","ConnectionPool","event","CMAP_EVENTS","APM_EVENTS","on","e","emit","Connection","CLUSTER_TIME_RECEIVED","clusterTime","Monitor","exports","HEARTBEAT_EVENTS","clear","error","markServerUnknown","SERVER_HEARTBEAT_SUCCEEDED","DESCRIPTION_RECEIVED","ServerDescription","reply","roundTripTime","calculateRoundTripTime","duration","CONNECT","name","address","autoEncrypter","connect","destroy","callback","Object","assign","force","close","err","requestCheck","command","ns","cmd","MongoDriverError","db","finalOptions","wireProtocolCommand","collationNotSupported","withConnection","conn","cb","makeOperationHandler","query","getMore","cursorId","killCursors","cursorIds","undefined","SERVER_HEARTBEAT_STARTED","SERVER_HEARTBEAT_FAILED","CLOSED","ENDED","defineProperty","prototype","get","set","supportsRetryableWrites","server","maxWireVersion","logicalSessionTimeoutMinutes","type","ServerType","Standalone","oldRtt","alpha","MongoNetworkError","MongoNetworkTimeoutError","reset","topologyVersion","connectionIsStale","connection","generation","shouldHandleStateChangeError","etv","stv","compareTopologyVersion","inActiveTransaction","session","inTransaction","isTransactionCommand","isRetryableWritesEnabled","retryWrites","handleOperationResult","result","hasEnded","serverSession","isDirty","addErrorLabel","isNetworkErrorBeforeHandshake","isRetryableWriteError","isSDAMUnrecoverableError","isNodeShuttingDownError","process","nextTick"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\sdam\\server.ts"],"sourcesContent":["import { Logger } from '../logger';\nimport {\n  ConnectionPool,\n  ConnectionPoolOptions,\n  CMAP_EVENTS,\n  ConnectionPoolEvents\n} from '../cmap/connection_pool';\nimport { ServerDescription, compareTopologyVersion } from './server_description';\nimport { Monitor, MonitorOptions } from './monitor';\nimport { isTransactionCommand } from '../transactions';\nimport {\n  collationNotSupported,\n  makeStateMachine,\n  maxWireVersion,\n  Callback,\n  CallbackWithType,\n  MongoDBNamespace,\n  EventEmitterWithState\n} from '../utils';\nimport {\n  ServerType,\n  STATE_CLOSED,\n  STATE_CLOSING,\n  STATE_CONNECTING,\n  STATE_CONNECTED,\n  ClusterTime\n} from './common';\nimport {\n  MongoError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  isSDAMUnrecoverableError,\n  isRetryableWriteError,\n  isNodeShuttingDownError,\n  isNetworkErrorBeforeHandshake,\n  MongoDriverError\n} from '../error';\nimport {\n  Connection,\n  DestroyOptions,\n  QueryOptions,\n  GetMoreOptions,\n  CommandOptions,\n  APM_EVENTS\n} from '../cmap/connection';\nimport type { Topology } from './topology';\nimport type {\n  ServerHeartbeatFailedEvent,\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent\n} from './events';\nimport type { ClientSession } from '../sessions';\nimport type { Document, Long } from '../bson';\nimport type { AutoEncrypter } from '../deps';\nimport type { ServerApi } from '../mongo_client';\nimport { TypedEventEmitter } from '../mongo_types';\n\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],\n  [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],\n  [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]\n});\n\n/** @internal */\nconst kMonitor = Symbol('monitor');\n\n/** @public */\nexport type ServerOptions = Omit<ConnectionPoolOptions, 'id' | 'generation' | 'hostAddress'> &\n  MonitorOptions;\n\n/** @internal */\nexport interface ServerPrivate {\n  /** The server description for this server */\n  description: ServerDescription;\n  /** A copy of the options used to construct this instance */\n  options: ServerOptions;\n  /** A logger instance */\n  logger: Logger;\n  /** The current state of the Server */\n  state: string;\n  /** The topology this server is a part of */\n  topology: Topology;\n  /** A connection pool for this server */\n  pool: ConnectionPool;\n  /** MongoDB server API version */\n  serverApi?: ServerApi;\n}\n\n/** @public */\nexport type ServerEvents = {\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\n  /** Top level MongoClient doesn't emit this so it is marked: @internal */\n  connect(server: Server): void;\n  descriptionReceived(description: ServerDescription): void;\n  closed(): void;\n  ended(): void;\n} & ConnectionPoolEvents &\n  EventEmitterWithState;\n\n/** @internal */\nexport class Server extends TypedEventEmitter<ServerEvents> {\n  /** @internal */\n  s: ServerPrivate;\n  serverApi?: ServerApi;\n  clusterTime?: ClusterTime;\n  ismaster?: Document;\n  [kMonitor]: Monitor;\n\n  /** @event */\n  static readonly SERVER_HEARTBEAT_STARTED = 'serverHeartbeatStarted' as const;\n  /** @event */\n  static readonly SERVER_HEARTBEAT_SUCCEEDED = 'serverHeartbeatSucceeded' as const;\n  /** @event */\n  static readonly SERVER_HEARTBEAT_FAILED = 'serverHeartbeatFailed' as const;\n  /** @event */\n  static readonly CONNECT = 'connect' as const;\n  /** @event */\n  static readonly DESCRIPTION_RECEIVED = 'descriptionReceived' as const;\n  /** @event */\n  static readonly CLOSED = 'closed' as const;\n  /** @event */\n  static readonly ENDED = 'ended' as const;\n\n  /**\n   * Create a server\n   */\n  constructor(topology: Topology, description: ServerDescription, options: ServerOptions) {\n    super();\n\n    this.serverApi = options.serverApi;\n\n    const poolOptions = { hostAddress: description.hostAddress, ...options };\n\n    this.s = {\n      description,\n      options,\n      logger: new Logger('Server'),\n      state: STATE_CLOSED,\n      topology,\n      pool: new ConnectionPool(poolOptions)\n    };\n\n    for (const event of [...CMAP_EVENTS, ...APM_EVENTS]) {\n      this.s.pool.on(event, (e: any) => this.emit(event, e));\n    }\n\n    this.s.pool.on(Connection.CLUSTER_TIME_RECEIVED, (clusterTime: ClusterTime) => {\n      this.clusterTime = clusterTime;\n    });\n\n    // create the monitor\n    this[kMonitor] = new Monitor(this, this.s.options);\n\n    for (const event of HEARTBEAT_EVENTS) {\n      this[kMonitor].on(event, (e: any) => this.emit(event, e));\n    }\n\n    this[kMonitor].on('resetConnectionPool', () => {\n      this.s.pool.clear();\n    });\n\n    this[kMonitor].on('resetServer', (error: MongoError) => markServerUnknown(this, error));\n    this[kMonitor].on(Server.SERVER_HEARTBEAT_SUCCEEDED, (event: ServerHeartbeatSucceededEvent) => {\n      this.emit(\n        Server.DESCRIPTION_RECEIVED,\n        new ServerDescription(this.description.hostAddress, event.reply, {\n          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)\n        })\n      );\n\n      if (this.s.state === STATE_CONNECTING) {\n        stateTransition(this, STATE_CONNECTED);\n        this.emit(Server.CONNECT, this);\n      }\n    });\n  }\n\n  get description(): ServerDescription {\n    return this.s.description;\n  }\n\n  get name(): string {\n    return this.s.description.address;\n  }\n\n  get autoEncrypter(): AutoEncrypter | undefined {\n    if (this.s.options && this.s.options.autoEncrypter) {\n      return this.s.options.autoEncrypter;\n    }\n  }\n\n  /**\n   * Initiate server connect\n   */\n  connect(): void {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    stateTransition(this, STATE_CONNECTING);\n    this[kMonitor].connect();\n  }\n\n  /** Destroy the server connection */\n  destroy(options?: DestroyOptions, callback?: Callback): void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = Object.assign({}, { force: false }, options);\n\n    if (this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n\n    this[kMonitor].close();\n    this.s.pool.close(options, err => {\n      stateTransition(this, STATE_CLOSED);\n      this.emit('closed');\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  /**\n   * Immediately schedule monitoring of this server. If there already an attempt being made\n   * this will be a no-op.\n   */\n  requestCheck(): void {\n    this[kMonitor].requestCheck();\n  }\n\n  /**\n   * Execute a command\n   * @internal\n   */\n  command(ns: MongoDBNamespace, cmd: Document, callback: Callback): void;\n  /** @internal */\n  command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions,\n    callback: Callback<Document>\n  ): void;\n  command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options?: CommandOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): void {\n    if (typeof options === 'function') {\n      (callback = options), (options = {}), (options = options ?? {});\n    }\n\n    if (callback == null) {\n      throw new MongoDriverError('callback must be provided');\n    }\n\n    if (ns.db == null || typeof ns === 'string') {\n      throw new MongoDriverError('ns must not be a string');\n    }\n\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoDriverError('server is closed'));\n      return;\n    }\n\n    // Clone the options\n    const finalOptions = Object.assign({}, options, { wireProtocolCommand: false });\n\n    // error if collation not supported\n    if (collationNotSupported(this, cmd)) {\n      callback(new MongoDriverError(`server ${this.name} does not support collation`));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.command(\n        ns,\n        cmd,\n        finalOptions,\n        makeOperationHandler(this, conn, cmd, finalOptions, cb) as Callback<Document>\n      );\n    }, callback);\n  }\n\n  /**\n   * Execute a query against the server\n   * @internal\n   */\n  query(ns: MongoDBNamespace, cmd: Document, options: QueryOptions, callback: Callback): void {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoDriverError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.query(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb) as Callback);\n    }, callback);\n  }\n\n  /**\n   * Execute a `getMore` against the server\n   * @internal\n   */\n  getMore(\n    ns: MongoDBNamespace,\n    cursorId: Long,\n    options: GetMoreOptions,\n    callback: Callback<Document>\n  ): void {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      callback(new MongoDriverError('server is closed'));\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.getMore(\n        ns,\n        cursorId,\n        options,\n        makeOperationHandler(this, conn, {}, options, cb) as Callback\n      );\n    }, callback);\n  }\n\n  /**\n   * Execute a `killCursors` command against the server\n   * @internal\n   */\n  killCursors(\n    ns: MongoDBNamespace,\n    cursorIds: Long[],\n    options: CommandOptions,\n    callback?: Callback\n  ): void {\n    if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n      if (typeof callback === 'function') {\n        callback(new MongoDriverError('server is closed'));\n      }\n\n      return;\n    }\n\n    this.s.pool.withConnection((err, conn, cb) => {\n      if (err || !conn) {\n        markServerUnknown(this, err);\n        return cb(err);\n      }\n\n      conn.killCursors(\n        ns,\n        cursorIds,\n        options,\n        makeOperationHandler(this, conn, {}, undefined, cb) as Callback\n      );\n    }, callback);\n  }\n}\n\nexport const HEARTBEAT_EVENTS = [\n  Server.SERVER_HEARTBEAT_STARTED,\n  Server.SERVER_HEARTBEAT_SUCCEEDED,\n  Server.SERVER_HEARTBEAT_FAILED\n];\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get() {\n    return this.s.topology.clusterTime;\n  },\n  set(clusterTime: ClusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction supportsRetryableWrites(server: Server) {\n  return (\n    server.description.maxWireVersion >= 6 &&\n    server.description.logicalSessionTimeoutMinutes &&\n    server.description.type !== ServerType.Standalone\n  );\n}\n\nfunction calculateRoundTripTime(oldRtt: number, duration: number): number {\n  if (oldRtt === -1) {\n    return duration;\n  }\n\n  const alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\n\nfunction markServerUnknown(server: Server, error?: MongoError) {\n  if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {\n    server[kMonitor].reset();\n  }\n\n  server.emit(\n    Server.DESCRIPTION_RECEIVED,\n    new ServerDescription(server.description.hostAddress, undefined, {\n      error,\n      topologyVersion:\n        error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion\n    })\n  );\n}\n\nfunction connectionIsStale(pool: ConnectionPool, connection: Connection) {\n  return connection.generation !== pool.generation;\n}\n\nfunction shouldHandleStateChangeError(server: Server, err: MongoError) {\n  const etv = err.topologyVersion;\n  const stv = server.description.topologyVersion;\n  return compareTopologyVersion(stv, etv) < 0;\n}\n\nfunction inActiveTransaction(session: ClientSession | undefined, cmd: Document) {\n  return session && session.inTransaction() && !isTransactionCommand(cmd);\n}\n\n/** this checks the retryWrites option passed down from the client options, it\n * does not check if the server supports retryable writes */\nfunction isRetryableWritesEnabled(topology: Topology) {\n  return topology.s.options.retryWrites !== false;\n}\n\nfunction makeOperationHandler(\n  server: Server,\n  connection: Connection,\n  cmd: Document,\n  options: CommandOptions | GetMoreOptions | undefined,\n  callback: Callback\n): CallbackWithType<MongoError, Document> {\n  const session = options?.session;\n  return function handleOperationResult(err, result) {\n    if (err && !connectionIsStale(server.s.pool, connection)) {\n      if (err instanceof MongoNetworkError) {\n        if (session && !session.hasEnded && session.serverSession) {\n          session.serverSession.isDirty = true;\n        }\n\n        if (\n          (isRetryableWritesEnabled(server.s.topology) || isTransactionCommand(cmd)) &&\n          supportsRetryableWrites(server) &&\n          !inActiveTransaction(session, cmd)\n        ) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else {\n        // if pre-4.4 server, then add error label if its a retryable write error\n        if (\n          (isRetryableWritesEnabled(server.s.topology) || isTransactionCommand(cmd)) &&\n          maxWireVersion(server) < 9 &&\n          isRetryableWriteError(err) &&\n          !inActiveTransaction(session, cmd)\n        ) {\n          err.addErrorLabel('RetryableWriteError');\n        }\n\n        if (isSDAMUnrecoverableError(err)) {\n          if (shouldHandleStateChangeError(server, err)) {\n            if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n              server.s.pool.clear();\n            }\n\n            markServerUnknown(server, err);\n            process.nextTick(() => server.requestCheck());\n          }\n        }\n      }\n    }\n\n    callback(err, result);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}