{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RTTPinger = exports.Monitor = void 0;\nconst common_1 = require(\"./common\");\nconst utils_1 = require(\"../utils\");\nconst connect_1 = require(\"../cmap/connect\");\nconst connection_1 = require(\"../cmap/connection\");\nconst error_1 = require(\"../error\");\nconst bson_1 = require(\"../bson\");\nconst events_1 = require(\"./events\");\nconst server_1 = require(\"./server\");\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kConnection = Symbol('connection');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kRTTPinger = Symbol('rttPinger');\n/** @internal */\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = utils_1.makeStateMachine({\n  [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n  [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor) {\n  return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @internal */\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n  constructor(server, options) {\n    var _a, _b, _c;\n    super();\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: common_1.STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: (_a = options.connectTimeoutMS) !== null && _a !== void 0 ? _a : 10000,\n      heartbeatFrequencyMS: (_b = options.heartbeatFrequencyMS) !== null && _b !== void 0 ? _b : 10000,\n      minHeartbeatFrequencyMS: (_c = options.minHeartbeatFrequencyMS) !== null && _c !== void 0 ? _c : 500\n    });\n    const cancellationToken = this[kCancellationToken];\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      generation: server.s.pool.generation,\n      connectionType: connection_1.Connection,\n      cancellationToken,\n      hostAddress: server.description.hostAddress\n    }, options,\n    // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    });\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n  connect() {\n    if (this.s.state !== common_1.STATE_CLOSED) {\n      return;\n    }\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = utils_1.makeInterruptibleAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n  requestCheck() {\n    var _a;\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n    (_a = this[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n  }\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = utils_1.makeInterruptibleAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n    stateTransition(this, common_1.STATE_CLOSING);\n    resetMonitorState(this);\n    // close monitor\n    this.emit('close');\n    stateTransition(this, common_1.STATE_CLOSED);\n  }\n}\nexports.Monitor = Monitor;\nfunction resetMonitorState(monitor) {\n  var _a, _b, _c;\n  (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.stop();\n  monitor[kMonitorId] = undefined;\n  (_b = monitor[kRTTPinger]) === null || _b === void 0 ? void 0 : _b.close();\n  monitor[kRTTPinger] = undefined;\n  monitor[kCancellationToken].emit('cancel');\n  (_c = monitor[kConnection]) === null || _c === void 0 ? void 0 : _c.destroy({\n    force: true\n  });\n  monitor[kConnection] = undefined;\n}\nfunction checkServer(monitor, callback) {\n  let start = utils_1.now();\n  monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n  function failureHandler(err) {\n    var _a;\n    (_a = monitor[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n      force: true\n    });\n    monitor[kConnection] = undefined;\n    monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, utils_1.calculateDurationInMs(start), err));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n  const connection = monitor[kConnection];\n  if (connection && !connection.closed) {\n    const {\n      serverApi,\n      helloOk\n    } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = {\n      [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) || helloOk ? 'hello' : 'ismaster']: true,\n      ...(isAwaitable && topologyVersion ? {\n        maxAwaitTimeMS,\n        topologyVersion: makeTopologyVersion(topologyVersion)\n      } : {})\n    };\n    const options = isAwaitable ? {\n      socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n      exhaustAllowed: true\n    } : {\n      socketTimeoutMS: connectTimeoutMS\n    };\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({\n        heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS\n      }, monitor.connectOptions));\n    }\n    connection.command(utils_1.ns('admin.$cmd'), cmd, options, (err, isMaster) => {\n      var _a;\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n      if ('isWritablePrimary' in isMaster) {\n        // Provide pre-hello-style response document.\n        isMaster.ismaster = isMaster.isWritablePrimary;\n      }\n      const rttPinger = monitor[kRTTPinger];\n      const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : utils_1.calculateDurationInMs(start);\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, isMaster));\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));\n        start = utils_1.now();\n      } else {\n        (_a = monitor[kRTTPinger]) === null || _a === void 0 ? void 0 : _a.close();\n        monitor[kRTTPinger] = undefined;\n        callback(undefined, isMaster);\n      }\n    });\n    return;\n  }\n  // connecting does an implicit `ismaster`\n  connect_1.connect(monitor.connectOptions, (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      // we already reset the connection pool on network errors in all cases\n      if (!(err instanceof error_1.MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n      failureHandler(err);\n      return;\n    }\n    if (conn) {\n      if (isInCloseState(monitor)) {\n        conn.destroy({\n          force: true\n        });\n        return;\n      }\n      monitor[kConnection] = conn;\n      monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, utils_1.calculateDurationInMs(start), conn.ismaster));\n      callback(undefined, conn.ismaster);\n    }\n  });\n}\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n      callback();\n    }\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === common_1.ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      }\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          var _a;\n          if (!isInCloseState(monitor)) {\n            (_a = monitor[kMonitorId]) === null || _a === void 0 ? void 0 : _a.wake();\n          }\n        }, 0);\n      }\n      done();\n    });\n  };\n}\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n  };\n}\n/** @internal */\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n  close() {\n    var _a;\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n    (_a = this[kConnection]) === null || _a === void 0 ? void 0 : _a.destroy({\n      force: true\n    });\n    this[kConnection] = undefined;\n  }\n}\nexports.RTTPinger = RTTPinger;\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = utils_1.now();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n  if (rttPinger.closed) {\n    return;\n  }\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn === null || conn === void 0 ? void 0 : conn.destroy({\n        force: true\n      });\n      return;\n    }\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n    rttPinger[kRoundTripTime] = utils_1.calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n  const connection = rttPinger[kConnection];\n  if (connection == null) {\n    connect_1.connect(options, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n  connection.command(utils_1.ns('admin.$cmd'), {\n    ismaster: 1\n  }, undefined, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n    measureAndReschedule();\n  });\n}","map":{"version":3,"names":["common_1","require","utils_1","connect_1","connection_1","error_1","bson_1","events_1","server_1","mongo_types_1","kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kRTTPinger","kRoundTripTime","STATE_IDLE","STATE_MONITORING","stateTransition","makeStateMachine","STATE_CLOSING","STATE_CLOSED","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","TypedEventEmitter","constructor","server","options","undefined","CancellationToken","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","_a","heartbeatFrequencyMS","_b","minHeartbeatFrequencyMS","_c","cancellationToken","connectOptions","assign","id","generation","pool","connectionType","Connection","hostAddress","raw","promoteLongs","promoteValues","promoteBuffers","credentials","autoEncrypter","connect","makeInterruptibleAsyncInterval","monitorServer","interval","minInterval","immediate","requestCheck","has","wake","reset","topologyVersion","resetMonitorState","close","emit","exports","stop","destroy","force","checkServer","callback","start","now","Server","SERVER_HEARTBEAT_STARTED","ServerHeartbeatStartedEvent","failureHandler","err","SERVER_HEARTBEAT_FAILED","ServerHeartbeatFailedEvent","calculateDurationInMs","connection","closed","serverApi","helloOk","maxAwaitTimeMS","isAwaitable","cmd","version","makeTopologyVersion","socketTimeoutMS","exhaustAllowed","RTTPinger","command","ns","isMaster","ismaster","isWritablePrimary","rttPinger","duration","roundTripTime","SERVER_HEARTBEAT_SUCCEEDED","ServerHeartbeatSucceededEvent","conn","MongoNetworkError","done","type","ServerType","Unknown","setTimeout","tv","processId","counter","Long","isLong","fromNumber","measureRoundTripTime","clearTimeout","measureAndReschedule"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\sdam\\monitor.ts"],"sourcesContent":["import { ServerType, STATE_CLOSED, STATE_CLOSING } from './common';\nimport {\n  now,\n  makeStateMachine,\n  calculateDurationInMs,\n  makeInterruptibleAsyncInterval,\n  ns,\n  EventEmitterWithState\n} from '../utils';\nimport { connect } from '../cmap/connect';\nimport { Connection, ConnectionOptions } from '../cmap/connection';\nimport { MongoNetworkError, AnyError } from '../error';\nimport { Long, Document } from '../bson';\nimport {\n  ServerHeartbeatStartedEvent,\n  ServerHeartbeatSucceededEvent,\n  ServerHeartbeatFailedEvent\n} from './events';\n\nimport { Server } from './server';\nimport type { InterruptibleAsyncInterval, Callback } from '../utils';\nimport type { TopologyVersion } from './server_description';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\n\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kMonitorId = Symbol('monitorId');\n/** @internal */\nconst kConnection = Symbol('connection');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kRTTPinger = Symbol('rttPinger');\n/** @internal */\nconst kRoundTripTime = Symbol('roundTripTime');\n\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor: Monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\n/** @internal */\nexport interface MonitorPrivate {\n  state: string;\n}\n\n/** @public */\nexport interface MonitorOptions\n  extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {\n  connectTimeoutMS: number;\n  heartbeatFrequencyMS: number;\n  minHeartbeatFrequencyMS: number;\n}\n\n/** @public */\nexport type MonitorEvents = {\n  serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;\n  serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;\n  serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;\n  resetServer(error?: Error): void;\n  resetConnectionPool(): void;\n  close(): void;\n} & EventEmitterWithState;\n\n/** @internal */\nexport class Monitor extends TypedEventEmitter<MonitorEvents> {\n  /** @internal */\n  s: MonitorPrivate;\n  address: string;\n  options: Readonly<\n    Pick<MonitorOptions, 'connectTimeoutMS' | 'heartbeatFrequencyMS' | 'minHeartbeatFrequencyMS'>\n  >;\n  connectOptions: ConnectionOptions;\n  [kServer]: Server;\n  [kConnection]?: Connection;\n  [kCancellationToken]: CancellationToken;\n  /** @internal */\n  [kMonitorId]?: InterruptibleAsyncInterval;\n  [kRTTPinger]?: RTTPinger;\n\n  constructor(server: Server, options: MonitorOptions) {\n    super();\n\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = undefined;\n    this.s = {\n      state: STATE_CLOSED\n    };\n\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: options.connectTimeoutMS ?? 10000,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500\n    });\n\n    const cancellationToken = this[kCancellationToken];\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign(\n      {\n        id: '<monitor>' as const,\n        generation: server.s.pool.generation,\n        connectionType: Connection,\n        cancellationToken,\n        hostAddress: server.description.hostAddress\n      },\n      options,\n      // force BSON serialization options\n      {\n        raw: false,\n        promoteLongs: true,\n        promoteValues: true,\n        promoteBuffers: true\n      }\n    );\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    if (connectOptions.autoEncrypter) {\n      delete connectOptions.autoEncrypter;\n    }\n\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect(): void {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptibleAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck(): void {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId]?.wake();\n  }\n\n  reset(): void {\n    const topologyVersion = this[kServer].description.topologyVersion;\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptibleAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close(): void {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\n\nfunction resetMonitorState(monitor: Monitor) {\n  monitor[kMonitorId]?.stop();\n  monitor[kMonitorId] = undefined;\n\n  monitor[kRTTPinger]?.close();\n  monitor[kRTTPinger] = undefined;\n\n  monitor[kCancellationToken].emit('cancel');\n\n  monitor[kConnection]?.destroy({ force: true });\n  monitor[kConnection] = undefined;\n}\n\nfunction checkServer(monitor: Monitor, callback: Callback<Document>) {\n  let start = now();\n  monitor.emit(Server.SERVER_HEARTBEAT_STARTED, new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err: AnyError) {\n    monitor[kConnection]?.destroy({ force: true });\n    monitor[kConnection] = undefined;\n\n    monitor.emit(\n      Server.SERVER_HEARTBEAT_FAILED,\n      new ServerHeartbeatFailedEvent(monitor.address, calculateDurationInMs(start), err)\n    );\n\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  const connection = monitor[kConnection];\n  if (connection && !connection.closed) {\n    const { serverApi, helloOk } = connection;\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n\n    const cmd = {\n      [serverApi?.version || helloOk ? 'hello' : 'ismaster']: true,\n      ...(isAwaitable && topologyVersion\n        ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n        : {})\n    };\n\n    const options = isAwaitable\n      ? {\n          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n          exhaustAllowed: true\n        }\n      : { socketTimeoutMS: connectTimeoutMS };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(\n        monitor[kCancellationToken],\n        Object.assign(\n          { heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS },\n          monitor.connectOptions\n        )\n      );\n    }\n\n    connection.command(ns('admin.$cmd'), cmd, options, (err, isMaster) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n      if ('isWritablePrimary' in isMaster) {\n        // Provide pre-hello-style response document.\n        isMaster.ismaster = isMaster.isWritablePrimary;\n      }\n\n      const rttPinger = monitor[kRTTPinger];\n      const duration =\n        isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);\n\n      monitor.emit(\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\n        new ServerHeartbeatSucceededEvent(monitor.address, duration, isMaster)\n      );\n\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit(\n          Server.SERVER_HEARTBEAT_STARTED,\n          new ServerHeartbeatStartedEvent(monitor.address)\n        );\n        start = now();\n      } else {\n        monitor[kRTTPinger]?.close();\n        monitor[kRTTPinger] = undefined;\n\n        callback(undefined, isMaster);\n      }\n    });\n\n    return;\n  }\n\n  // connecting does an implicit `ismaster`\n  connect(monitor.connectOptions, (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n\n      // we already reset the connection pool on network errors in all cases\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    if (conn) {\n      if (isInCloseState(monitor)) {\n        conn.destroy({ force: true });\n        return;\n      }\n\n      monitor[kConnection] = conn;\n      monitor.emit(\n        Server.SERVER_HEARTBEAT_SUCCEEDED,\n        new ServerHeartbeatSucceededEvent(\n          monitor.address,\n          calculateDurationInMs(start),\n          conn.ismaster\n        )\n      );\n\n      callback(undefined, conn.ismaster);\n    }\n  });\n}\n\nfunction monitorServer(monitor: Monitor) {\n  return (callback: Callback) => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occurred on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId]?.wake();\n          }\n        }, 0);\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv: TopologyVersion) {\n  return {\n    processId: tv.processId,\n    // tests mock counter as just number, but in a real situation counter should always be a Long\n    counter: Long.isLong(tv.counter) ? tv.counter : Long.fromNumber(tv.counter)\n  };\n}\n\n/** @internal */\nexport interface RTTPingerOptions extends ConnectionOptions {\n  heartbeatFrequencyMS: number;\n}\n\n/** @internal */\nexport class RTTPinger {\n  /** @internal */\n  [kConnection]?: Connection;\n  /** @internal */\n  [kCancellationToken]: CancellationToken;\n  /** @internal */\n  [kRoundTripTime]: number;\n  /** @internal */\n  [kMonitorId]: NodeJS.Timeout;\n  closed: boolean;\n\n  constructor(cancellationToken: CancellationToken, options: RTTPingerOptions) {\n    this[kConnection] = undefined;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime(): number {\n    return this[kRoundTripTime];\n  }\n\n  close(): void {\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n\n    this[kConnection]?.destroy({ force: true });\n    this[kConnection] = undefined;\n  }\n}\n\nfunction measureRoundTripTime(rttPinger: RTTPinger, options: RTTPingerOptions) {\n  const start = now();\n  options.cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn?: Connection) {\n    if (rttPinger.closed) {\n      conn?.destroy({ force: true });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(\n      () => measureRoundTripTime(rttPinger, options),\n      heartbeatFrequencyMS\n    );\n  }\n\n  const connection = rttPinger[kConnection];\n  if (connection == null) {\n    connect(options, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n\n    return;\n  }\n\n  connection.command(ns('admin.$cmd'), { ismaster: 1 }, undefined, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}