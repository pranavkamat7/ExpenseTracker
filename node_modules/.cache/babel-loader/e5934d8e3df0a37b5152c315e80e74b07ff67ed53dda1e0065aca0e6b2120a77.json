{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\nconst utils_1 = require(\"./utils\");\nconst read_preference_1 = require(\"./read_preference\");\nconst utils_2 = require(\"./utils\");\nconst bson_1 = require(\"./bson\");\nconst error_1 = require(\"./error\");\nconst unordered_1 = require(\"./bulk/unordered\");\nconst ordered_1 = require(\"./bulk/ordered\");\nconst change_stream_1 = require(\"./change_stream\");\nconst write_concern_1 = require(\"./write_concern\");\nconst read_concern_1 = require(\"./read_concern\");\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nconst bulk_write_1 = require(\"./operations/bulk_write\");\nconst count_documents_1 = require(\"./operations/count_documents\");\nconst indexes_1 = require(\"./operations/indexes\");\nconst distinct_1 = require(\"./operations/distinct\");\nconst drop_1 = require(\"./operations/drop\");\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nconst find_one_1 = require(\"./operations/find_one\");\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\nconst insert_1 = require(\"./operations/insert\");\nconst update_1 = require(\"./operations/update\");\nconst delete_1 = require(\"./operations/delete\");\nconst is_capped_1 = require(\"./operations/is_capped\");\nconst map_reduce_1 = require(\"./operations/map_reduce\");\nconst options_operation_1 = require(\"./operations/options_operation\");\nconst rename_1 = require(\"./operations/rename\");\nconst stats_1 = require(\"./operations/stats\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\nclass Collection {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db, name, options) {\n    var _a, _b;\n    utils_2.checkCollectionName(name);\n    // Internal state\n    this.s = {\n      db,\n      options,\n      namespace: new utils_2.MongoDBNamespace(db.databaseName, name),\n      pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: bson_1.resolveBSONOptions(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n      slaveOk: options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk\n    };\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n  get dbName() {\n    return this.s.namespace.db;\n  }\n  /**\n   * The name of this collection\n   */\n  get collectionName() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection;\n  }\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n  get namespace() {\n    return this.s.namespace.toString();\n  }\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readConcern() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n    return this.s.readPreference;\n  }\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get writeConcern() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n  /** The current index hint for the collection */\n  get hint() {\n    return this.s.collectionHint;\n  }\n  set hint(v) {\n    this.s.collectionHint = utils_2.normalizeHintField(v);\n  }\n  insertOne(doc, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n    // we support that option style here only\n    if (options && Reflect.get(options, 'w')) {\n      options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n    }\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertOneOperation(this, doc, utils_1.resolveOptions(this, options)), callback);\n  }\n  insertMany(docs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {\n      ordered: true\n    };\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertManyOperation(this, docs, utils_1.resolveOptions(this, options)), callback);\n  }\n  bulkWrite(operations, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: true\n    };\n    if (!Array.isArray(operations)) {\n      throw new error_1.MongoDriverError('operations must be an array of documents');\n    }\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new bulk_write_1.BulkWriteOperation(this, operations, utils_1.resolveOptions(this, options)), callback);\n  }\n  updateOne(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateOneOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n  replaceOne(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.ReplaceOneOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n  }\n  updateMany(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateManyOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n  deleteOne(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteOneOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n  deleteMany(filter, options, callback) {\n    if (filter == null) {\n      filter = {};\n      options = {};\n      callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteManyOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n  rename(newName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    // Intentionally, we do not inherit options from parent for this operation.\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new rename_1.RenameOperation(this, newName, {\n      ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }), callback);\n  }\n  drop(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n  }\n  findOne(filter, options, callback) {\n    if (callback !== undefined && typeof callback !== 'function') {\n      throw new error_1.MongoDriverError('Third parameter to `findOne()` must be a callback or undefined');\n    }\n    if (typeof filter === 'function') callback = filter, filter = {}, options = {};\n    if (typeof options === 'function') callback = options, options = {};\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_one_1.FindOneOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n  find(filter, options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoDriverError('Third parameter to `collection.find()` must be undefined');\n    }\n    if (typeof options === 'function') {\n      throw new error_1.MongoDriverError('`options` parameter must not be function');\n    }\n    return new find_cursor_1.FindCursor(utils_2.getTopology(this), this.s.namespace, filter, utils_1.resolveOptions(this, options));\n  }\n  options(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new options_operation_1.OptionsOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n  isCapped(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new is_capped_1.IsCappedOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n  createIndex(indexSpec, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, utils_1.resolveOptions(this, options)), callback);\n  }\n  createIndexes(indexSpecs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {};\n    if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, utils_1.resolveOptions(this, options)), callback);\n  }\n  dropIndex(indexName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = utils_1.resolveOptions(this, options);\n    // Run only against primary\n    options.readPreference = read_preference_1.ReadPreference.primary;\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexOperation(this, indexName, options), callback);\n  }\n  dropIndexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  listIndexes(options) {\n    return new indexes_1.ListIndexesCursor(this, utils_1.resolveOptions(this, options));\n  }\n  indexExists(indexes, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexExistsOperation(this, indexes, utils_1.resolveOptions(this, options)), callback);\n  }\n  indexInformation(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, utils_1.resolveOptions(this, options)), callback);\n  }\n  estimatedDocumentCount(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new estimated_document_count_1.EstimatedDocumentCountOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n  countDocuments(filter, options, callback) {\n    if (typeof filter === 'undefined') {\n      filter = {}, options = {}, callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 2) {\n        if (typeof options === 'function') callback = options, options = {};\n      }\n    }\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n  // Implementation\n  distinct(key, filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 3 && typeof options === 'function') {\n        callback = options, options = {};\n      }\n    }\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new distinct_1.DistinctOperation(this, key, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n  indexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n  stats(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new stats_1.CollStatsOperation(this, options), callback);\n  }\n  findOneAndDelete(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndDeleteOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n  findOneAndReplace(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n  }\n  findOneAndUpdate(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n  aggregate(pipeline = [], options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoDriverError('Third parameter to `collection.aggregate()` must be undefined');\n    }\n    if (!Array.isArray(pipeline)) {\n      throw new error_1.MongoDriverError('`pipeline` parameter must be an array of aggregation stages');\n    }\n    if (typeof options === 'function') {\n      throw new error_1.MongoDriverError('`options` parameter must not be function');\n    }\n    return new aggregation_cursor_1.AggregationCursor(this, utils_2.getTopology(this), this.s.namespace, pipeline, utils_1.resolveOptions(this, options));\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @since 3.0.0\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n  watch(pipeline = [], options = {}) {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n    return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n  }\n  mapReduce(map, reduce, options, callback) {\n    if ('function' === typeof options) callback = options, options = {};\n    // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n    // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n    if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n      throw new error_1.MongoDriverError('the out option parameter must be defined, see mongodb docs for possible values');\n    }\n    if ('function' === typeof map) {\n      map = map.toString();\n    }\n    if ('function' === typeof reduce) {\n      reduce = reduce.toString();\n    }\n    if ('function' === typeof options.finalize) {\n      options.finalize = options.finalize.toString();\n    }\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new map_reduce_1.MapReduceOperation(this, map, reduce, utils_1.resolveOptions(this, options)), callback);\n  }\n  /** Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */\n  initializeUnorderedBulkOp(options) {\n    return new unordered_1.UnorderedBulkOperation(this, utils_1.resolveOptions(this, options));\n  }\n  /** Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types. */\n  initializeOrderedBulkOp(options) {\n    return new ordered_1.OrderedBulkOperation(this, utils_1.resolveOptions(this, options));\n  }\n  /** Get the db scoped logger */\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n  get logger() {\n    return this.s.db.s.logger;\n  }\n  /**\n   * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @deprecated Use insertOne, insertMany or bulkWrite instead.\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  insert(docs, options, callback) {\n    utils_1.emitWarningOnce('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: false\n    };\n    docs = !Array.isArray(docs) ? [docs] : docs;\n    if (options.keepGoing === true) {\n      options.ordered = false;\n    }\n    return this.insertMany(docs, options, callback);\n  }\n  /**\n   * Updates documents.\n   *\n   * @deprecated use updateOne, updateMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  update(selector, update, options, callback) {\n    utils_1.emitWarningOnce('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.updateMany(selector, update, options, callback);\n  }\n  /**\n   * Remove documents.\n   *\n   * @deprecated use deleteOne, deleteMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  remove(selector, options, callback) {\n    utils_1.emitWarningOnce('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.deleteMany(selector, options, callback);\n  }\n  count(filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (typeof options === 'function') callback = options, options = {};\n    }\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n}\nexports.Collection = Collection;","map":{"version":3,"names":["utils_1","require","read_preference_1","utils_2","bson_1","error_1","unordered_1","ordered_1","change_stream_1","write_concern_1","read_concern_1","aggregation_cursor_1","bulk_write_1","count_documents_1","indexes_1","distinct_1","drop_1","estimated_document_count_1","find_one_1","find_and_modify_1","insert_1","update_1","delete_1","is_capped_1","map_reduce_1","options_operation_1","rename_1","stats_1","execute_operation_1","find_cursor_1","Collection","constructor","db","name","options","checkCollectionName","s","namespace","MongoDBNamespace","databaseName","pkFactory","_b","_a","DEFAULT_PK_FACTORY","readPreference","ReadPreference","fromOptions","bsonOptions","resolveBSONOptions","readConcern","ReadConcern","writeConcern","WriteConcern","slaveOk","dbName","collectionName","collection","toString","hint","collectionHint","v","normalizeHintField","insertOne","doc","callback","Reflect","get","executeOperation","getTopology","InsertOneOperation","resolveOptions","insertMany","docs","Object","assign","ordered","InsertManyOperation","bulkWrite","operations","Array","isArray","MongoDriverError","BulkWriteOperation","updateOne","filter","update","UpdateOneOperation","replaceOne","replacement","ReplaceOneOperation","updateMany","UpdateManyOperation","deleteOne","DeleteOneOperation","deleteMany","undefined","DeleteManyOperation","rename","newName","RenameOperation","PRIMARY","drop","DropCollectionOperation","findOne","FindOneOperation","find","arguments","length","FindCursor","OptionsOperation","isCapped","IsCappedOperation","createIndex","indexSpec","CreateIndexOperation","createIndexes","indexSpecs","maxTimeMS","CreateIndexesOperation","dropIndex","indexName","primary","DropIndexOperation","dropIndexes","DropIndexesOperation","listIndexes","ListIndexesCursor","indexExists","indexes","IndexExistsOperation","indexInformation","IndexInformationOperation","estimatedDocumentCount","EstimatedDocumentCountOperation","countDocuments","CountDocumentsOperation","distinct","key","DistinctOperation","IndexesOperation","stats","CollStatsOperation","findOneAndDelete","FindOneAndDeleteOperation","findOneAndReplace","FindOneAndReplaceOperation","findOneAndUpdate","FindOneAndUpdateOperation","aggregate","pipeline","AggregationCursor","watch","ChangeStream","mapReduce","map","reduce","out","finalize","MapReduceOperation","initializeUnorderedBulkOp","UnorderedBulkOperation","initializeOrderedBulkOp","OrderedBulkOperation","getLogger","logger","insert","emitWarningOnce","keepGoing","selector","remove","count","exports"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\collection.ts"],"sourcesContent":["import { DEFAULT_PK_FACTORY, emitWarningOnce, resolveOptions } from './utils';\nimport { ReadPreference, ReadPreferenceLike } from './read_preference';\nimport {\n  normalizeHintField,\n  checkCollectionName,\n  MongoDBNamespace,\n  Callback,\n  getTopology\n} from './utils';\nimport { Document, BSONSerializeOptions, resolveBSONOptions } from './bson';\nimport { MongoDriverError } from './error';\nimport { UnorderedBulkOperation } from './bulk/unordered';\nimport { OrderedBulkOperation } from './bulk/ordered';\nimport { ChangeStream, ChangeStreamOptions } from './change_stream';\nimport { WriteConcern, WriteConcernOptions } from './write_concern';\nimport { ReadConcern, ReadConcernLike } from './read_concern';\nimport { AggregationCursor } from './cursor/aggregation_cursor';\nimport type { AggregateOptions } from './operations/aggregate';\nimport { BulkWriteOperation } from './operations/bulk_write';\nimport { CountDocumentsOperation, CountDocumentsOptions } from './operations/count_documents';\nimport {\n  CreateIndexesOperation,\n  CreateIndexOperation,\n  DropIndexOperation,\n  DropIndexesOperation,\n  IndexesOperation,\n  IndexExistsOperation,\n  IndexInformationOperation,\n  CreateIndexesOptions,\n  DropIndexesOptions,\n  ListIndexesOptions,\n  IndexSpecification,\n  IndexDescription,\n  ListIndexesCursor\n} from './operations/indexes';\nimport { DistinctOperation, DistinctOptions } from './operations/distinct';\nimport { DropCollectionOperation, DropCollectionOptions } from './operations/drop';\nimport {\n  EstimatedDocumentCountOperation,\n  EstimatedDocumentCountOptions\n} from './operations/estimated_document_count';\nimport type { FindOptions } from './operations/find';\nimport { FindOneOperation } from './operations/find_one';\nimport {\n  FindOneAndDeleteOperation,\n  FindOneAndReplaceOperation,\n  FindOneAndUpdateOperation,\n  FindOneAndDeleteOptions,\n  FindOneAndReplaceOptions,\n  FindOneAndUpdateOptions\n} from './operations/find_and_modify';\nimport {\n  InsertOneOperation,\n  InsertOneOptions,\n  InsertOneResult,\n  InsertManyOperation,\n  InsertManyResult\n} from './operations/insert';\nimport {\n  UpdateOneOperation,\n  UpdateManyOperation,\n  UpdateOptions,\n  UpdateResult,\n  ReplaceOneOperation,\n  ReplaceOptions\n} from './operations/update';\nimport {\n  DeleteOneOperation,\n  DeleteManyOperation,\n  DeleteOptions,\n  DeleteResult\n} from './operations/delete';\nimport { IsCappedOperation } from './operations/is_capped';\nimport {\n  MapReduceOperation,\n  MapFunction,\n  ReduceFunction,\n  MapReduceOptions\n} from './operations/map_reduce';\nimport { OptionsOperation } from './operations/options_operation';\nimport { RenameOperation, RenameOptions } from './operations/rename';\nimport { CollStats, CollStatsOperation, CollStatsOptions } from './operations/stats';\nimport { executeOperation } from './operations/execute_operation';\nimport type { Db } from './db';\nimport type { OperationOptions, Hint } from './operations/operation';\nimport type { IndexInformationOptions } from './operations/common_functions';\nimport type { BulkWriteResult, BulkWriteOptions, AnyBulkWriteOperation } from './bulk/common';\nimport type { PkFactory } from './mongo_client';\nimport type { Logger, LoggerOptions } from './logger';\nimport { FindCursor } from './cursor/find_cursor';\nimport type { CountOptions } from './operations/count';\nimport type {\n  Filter,\n  TODO_NODE_3286,\n  UpdateFilter,\n  WithId,\n  OptionalId,\n  Flatten\n} from './mongo_types';\n\n/** @public */\nexport interface ModifyResult<TSchema = Document> {\n  value?: TSchema;\n  lastErrorObject?: Document;\n  ok: 0 | 1;\n}\n\n/** @public */\nexport interface CollectionOptions\n  extends BSONSerializeOptions,\n    WriteConcernOptions,\n    LoggerOptions {\n  slaveOk?: boolean;\n  /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */\n  readConcern?: ReadConcernLike;\n  /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */\n  readPreference?: ReadPreferenceLike;\n}\n\n/** @internal */\nexport interface CollectionPrivate {\n  pkFactory: PkFactory;\n  db: Db;\n  options: any;\n  namespace: MongoDBNamespace;\n  readPreference?: ReadPreference;\n  bsonOptions: BSONSerializeOptions;\n  slaveOk?: boolean;\n  collectionHint?: Hint;\n  readConcern?: ReadConcern;\n  writeConcern?: WriteConcern;\n}\n\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\nexport class Collection<TSchema extends Document = Document> {\n  /** @internal */\n  s: CollectionPrivate;\n\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db: Db, name: string, options?: CollectionOptions) {\n    checkCollectionName(name);\n\n    // Internal state\n    this.s = {\n      db,\n      options,\n      namespace: new MongoDBNamespace(db.databaseName, name),\n      pkFactory: db.options?.pkFactory ?? DEFAULT_PK_FACTORY,\n      readPreference: ReadPreference.fromOptions(options),\n      bsonOptions: resolveBSONOptions(options, db),\n      readConcern: ReadConcern.fromOptions(options),\n      writeConcern: WriteConcern.fromOptions(options),\n      slaveOk: options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk\n    };\n  }\n\n  /**\n   * The name of the database this collection belongs to\n   */\n  get dbName(): string {\n    return this.s.namespace.db;\n  }\n\n  /**\n   * The name of this collection\n   */\n  get collectionName(): string {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection!;\n  }\n\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n  get namespace(): string {\n    return this.s.namespace.toString();\n  }\n\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readConcern(): ReadConcern | undefined {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get readPreference(): ReadPreference | undefined {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions(): BSONSerializeOptions {\n    return this.s.bsonOptions;\n  }\n\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n  get writeConcern(): WriteConcern | undefined {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n\n  /** The current index hint for the collection */\n  get hint(): Hint | undefined {\n    return this.s.collectionHint;\n  }\n\n  set hint(v: Hint | undefined) {\n    this.s.collectionHint = normalizeHintField(v);\n  }\n\n  /**\n   * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param doc - The document to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  insertOne(doc: OptionalId<TSchema>): Promise<InsertOneResult<TSchema>>;\n  insertOne(doc: OptionalId<TSchema>, callback: Callback<InsertOneResult<TSchema>>): void;\n  insertOne(doc: OptionalId<TSchema>, options: InsertOneOptions): Promise<InsertOneResult<TSchema>>;\n  insertOne(\n    doc: OptionalId<TSchema>,\n    options: InsertOneOptions,\n    callback: Callback<InsertOneResult<TSchema>>\n  ): void;\n  insertOne(\n    doc: OptionalId<TSchema>,\n    options?: InsertOneOptions | Callback<InsertOneResult<TSchema>>,\n    callback?: Callback<InsertOneResult<TSchema>>\n  ): Promise<InsertOneResult<TSchema>> | void {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n    // we support that option style here only\n    if (options && Reflect.get(options, 'w')) {\n      options.writeConcern = WriteConcern.fromOptions(Reflect.get(options, 'w'));\n    }\n\n    return executeOperation(\n      getTopology(this),\n      new InsertOneOperation(\n        this as TODO_NODE_3286,\n        doc,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  insertMany(docs: OptionalId<TSchema>[]): Promise<InsertManyResult<TSchema>>;\n  insertMany(docs: OptionalId<TSchema>[], callback: Callback<InsertManyResult<TSchema>>): void;\n  insertMany(\n    docs: OptionalId<TSchema>[],\n    options: BulkWriteOptions\n  ): Promise<InsertManyResult<TSchema>>;\n  insertMany(\n    docs: OptionalId<TSchema>[],\n    options: BulkWriteOptions,\n    callback: Callback<InsertManyResult<TSchema>>\n  ): void;\n  insertMany(\n    docs: OptionalId<TSchema>[],\n    options?: BulkWriteOptions | Callback<InsertManyResult<TSchema>>,\n    callback?: Callback<InsertManyResult<TSchema>>\n  ): Promise<InsertManyResult<TSchema>> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ? Object.assign({}, options) : { ordered: true };\n\n    return executeOperation(\n      getTopology(this),\n      new InsertManyOperation(\n        this as TODO_NODE_3286,\n        docs,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Perform a bulkWrite operation without a fluent API\n   *\n   * Legal operation types are\n   *\n   * ```js\n   *  { insertOne: { document: { a: 1 } } }\n   *\n   *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n   *\n   *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n   *\n   *  { updateMany: { filter: {}, update: {$set: {\"a.$[i].x\": 5}}, arrayFilters: [{ \"i.x\": 5 }]} }\n   *\n   *  { deleteOne: { filter: {c:1} } }\n   *\n   *  { deleteMany: { filter: {c:1} } }\n   *\n   *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true} }\n   *```\n   * Please note that raw operations are no longer accepted as of driver version 4.0.\n   *\n   * If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @param operations - Bulk operations to perform\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   * @throws MongoDriverError if operations is not an array\n   */\n  bulkWrite(operations: AnyBulkWriteOperation<TSchema>[]): Promise<BulkWriteResult>;\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    callback: Callback<BulkWriteResult>\n  ): void;\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options: BulkWriteOptions\n  ): Promise<BulkWriteResult>;\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options: BulkWriteOptions,\n    callback: Callback<BulkWriteResult>\n  ): void;\n  bulkWrite(\n    operations: AnyBulkWriteOperation<TSchema>[],\n    options?: BulkWriteOptions | Callback<BulkWriteResult>,\n    callback?: Callback<BulkWriteResult>\n  ): Promise<BulkWriteResult> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || { ordered: true };\n\n    if (!Array.isArray(operations)) {\n      throw new MongoDriverError('operations must be an array of documents');\n    }\n\n    return executeOperation(\n      getTopology(this),\n      new BulkWriteOperation(\n        this as TODO_NODE_3286,\n        operations as TODO_NODE_3286,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Update a single document in a collection\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - The update operations to be applied to the document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>\n  ): Promise<UpdateResult | Document>;\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options: UpdateOptions\n  ): Promise<UpdateResult | Document>;\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options: UpdateOptions,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema> | Partial<TSchema>,\n    options?: UpdateOptions | Callback<UpdateResult | Document>,\n    callback?: Callback<UpdateResult | Document>\n  ): Promise<UpdateResult | Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new UpdateOneOperation(this as TODO_NODE_3286, filter, update, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Replace a document in a collection with another document\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  replaceOne(filter: Filter<TSchema>, replacement: TSchema): Promise<UpdateResult | Document>;\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: TSchema,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: TSchema,\n    options: ReplaceOptions\n  ): Promise<UpdateResult | Document>;\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: TSchema,\n    options: ReplaceOptions,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  replaceOne(\n    filter: Filter<TSchema>,\n    replacement: TSchema,\n    options?: ReplaceOptions | Callback<UpdateResult | Document>,\n    callback?: Callback<UpdateResult | Document>\n  ): Promise<UpdateResult | Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new ReplaceOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Update multiple documents in a collection\n   *\n   * @param filter - The filter used to select the documents to update\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>\n  ): Promise<UpdateResult | Document>;\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: UpdateOptions\n  ): Promise<UpdateResult | Document>;\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: UpdateOptions,\n    callback: Callback<UpdateResult | Document>\n  ): void;\n  updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: UpdateOptions | Callback<UpdateResult | Document>,\n    callback?: Callback<UpdateResult | Document>\n  ): Promise<UpdateResult | Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new UpdateManyOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Delete a document from a collection\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  deleteOne(filter: Filter<TSchema>): Promise<DeleteResult>;\n  deleteOne(filter: Filter<TSchema>, callback: Callback<DeleteResult>): void;\n  deleteOne(filter: Filter<TSchema>, options: DeleteOptions): Promise<DeleteResult>;\n  deleteOne(\n    filter: Filter<TSchema>,\n    options: DeleteOptions,\n    callback?: Callback<DeleteResult>\n  ): void;\n  deleteOne(\n    filter: Filter<TSchema>,\n    options?: DeleteOptions | Callback<DeleteResult>,\n    callback?: Callback<DeleteResult>\n  ): Promise<DeleteResult> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new DeleteOneOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Delete multiple documents from a collection\n   *\n   * @param filter - The filter used to select the documents to remove\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  deleteMany(filter: Filter<TSchema>): Promise<DeleteResult>;\n  deleteMany(filter: Filter<TSchema>, callback: Callback<DeleteResult>): void;\n  deleteMany(filter: Filter<TSchema>, options: DeleteOptions): Promise<DeleteResult>;\n  deleteMany(\n    filter: Filter<TSchema>,\n    options: DeleteOptions,\n    callback: Callback<DeleteResult>\n  ): void;\n  deleteMany(\n    filter: Filter<TSchema>,\n    options?: DeleteOptions | Callback<DeleteResult>,\n    callback?: Callback<DeleteResult>\n  ): Promise<DeleteResult> | void {\n    if (filter == null) {\n      filter = {};\n      options = {};\n      callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter as Callback<DeleteResult>;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return executeOperation(\n      getTopology(this),\n      new DeleteManyOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Rename the collection.\n   *\n   * @remarks\n   * This operation does not inherit options from the Db or MongoClient.\n   *\n   * @param newName - New name of of the collection.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  rename(newName: string): Promise<Collection>;\n  rename(newName: string, callback: Callback<Collection>): void;\n  rename(newName: string, options: RenameOptions): Promise<Collection> | void;\n  rename(newName: string, options: RenameOptions, callback: Callback<Collection>): void;\n  rename(\n    newName: string,\n    options?: RenameOptions | Callback<Collection>,\n    callback?: Callback<Collection>\n  ): Promise<Collection> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    // Intentionally, we do not inherit options from parent for this operation.\n    return executeOperation(\n      getTopology(this),\n      new RenameOperation(this as TODO_NODE_3286, newName, {\n        ...options,\n        readPreference: ReadPreference.PRIMARY\n      }),\n      callback\n    );\n  }\n\n  /**\n   * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  drop(): Promise<boolean>;\n  drop(callback: Callback<boolean>): void;\n  drop(options: DropCollectionOptions): Promise<boolean>;\n  drop(options: DropCollectionOptions, callback: Callback<boolean>): void;\n  drop(\n    options?: DropCollectionOptions | Callback<boolean>,\n    callback?: Callback<boolean>\n  ): Promise<boolean> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return executeOperation(\n      getTopology(this),\n      new DropCollectionOperation(this.s.db, this.collectionName, options),\n      callback\n    );\n  }\n\n  /**\n   * Fetches the first document that matches the filter\n   *\n   * @param filter - Query for find Operation\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOne(): Promise<TSchema | undefined>;\n  findOne(callback: Callback<TSchema | undefined>): void;\n  findOne(filter: Filter<TSchema>): Promise<TSchema | undefined>;\n  findOne(filter: Filter<TSchema>, callback: Callback<TSchema | undefined>): void;\n  findOne(filter: Filter<TSchema>, options: FindOptions<TSchema>): Promise<TSchema | undefined>;\n  findOne(\n    filter: Filter<TSchema>,\n    options: FindOptions<TSchema>,\n    callback: Callback<TSchema | undefined>\n  ): void;\n\n  // allow an override of the schema.\n  findOne<T = TSchema>(): Promise<T | undefined>;\n  findOne<T = TSchema>(callback: Callback<T | undefined>): void;\n  findOne<T = TSchema>(filter: Filter<T>): Promise<T | undefined>;\n  findOne<T = TSchema>(filter: Filter<T>, options?: FindOptions<T>): Promise<T | undefined>;\n  findOne<T = TSchema>(\n    filter: Filter<T>,\n    options?: FindOptions<T>,\n    callback?: Callback<T | undefined>\n  ): void;\n\n  findOne(\n    filter?: Filter<TSchema> | Callback<TSchema | undefined>,\n    options?: FindOptions<TSchema> | Callback<TSchema | undefined>,\n    callback?: Callback<TSchema>\n  ): Promise<TSchema | undefined> | void {\n    if (callback !== undefined && typeof callback !== 'function') {\n      throw new MongoDriverError('Third parameter to `findOne()` must be a callback or undefined');\n    }\n\n    if (typeof filter === 'function')\n      (callback = filter as Callback<Document | undefined>), (filter = {}), (options = {});\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    filter ??= {};\n\n    return executeOperation(\n      getTopology(this),\n      new FindOneOperation(\n        this as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback as TODO_NODE_3286\n    );\n  }\n\n  /**\n   * Creates a cursor for a filter that can be used to iterate over results from MongoDB\n   *\n   * @param filter - The filter predicate. If unspecified, then all documents in the collection will match the predicate\n   */\n  find(): FindCursor<TSchema>;\n  find(filter: Filter<TSchema>, options?: FindOptions<TSchema>): FindCursor<TSchema>;\n  find<T = TSchema>(filter: Filter<T>, options?: FindOptions<T>): FindCursor<T>;\n  find(filter?: Filter<TSchema>, options?: FindOptions<TSchema>): FindCursor<TSchema> {\n    if (arguments.length > 2) {\n      throw new MongoDriverError('Third parameter to `collection.find()` must be undefined');\n    }\n    if (typeof options === 'function') {\n      throw new MongoDriverError('`options` parameter must not be function');\n    }\n\n    return new FindCursor<TSchema>(\n      getTopology(this),\n      this.s.namespace,\n      filter,\n      resolveOptions(this as TODO_NODE_3286, options)\n    );\n  }\n\n  /**\n   * Returns the options of the collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  options(): Promise<Document>;\n  options(callback: Callback<Document>): void;\n  options(options: OperationOptions): Promise<Document>;\n  options(options: OperationOptions, callback: Callback<Document>): void;\n  options(\n    options?: OperationOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new OptionsOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Returns if the collection is a capped collection\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  isCapped(): Promise<boolean>;\n  isCapped(callback: Callback<boolean>): void;\n  isCapped(options: OperationOptions): Promise<boolean>;\n  isCapped(options: OperationOptions, callback: Callback<boolean>): void;\n  isCapped(\n    options?: OperationOptions | Callback<boolean>,\n    callback?: Callback<boolean>\n  ): Promise<boolean> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new IsCappedOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Creates an index on the db and collection collection.\n   *\n   * @param indexSpec - The field name or index specification to create an index for\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   *\n   * @example\n   * ```js\n   * const collection = client.db('foo').collection('bar');\n   *\n   * await collection.createIndex({ a: 1, b: -1 });\n   *\n   * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n   * await collection.createIndex([ [c, 1], [d, -1] ]);\n   *\n   * // Equivalent to { e: 1 }\n   * await collection.createIndex('e');\n   *\n   * // Equivalent to { f: 1, g: 1 }\n   * await collection.createIndex(['f', 'g'])\n   *\n   * // Equivalent to { h: 1, i: -1 }\n   * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n   *\n   * // Equivalent to { j: 1, k: -1, l: 2d }\n   * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n   * ```\n   */\n  createIndex(indexSpec: IndexSpecification): Promise<string>;\n  createIndex(indexSpec: IndexSpecification, callback: Callback<string>): void;\n  createIndex(indexSpec: IndexSpecification, options: CreateIndexesOptions): Promise<string>;\n  createIndex(\n    indexSpec: IndexSpecification,\n    options: CreateIndexesOptions,\n    callback: Callback<string>\n  ): void;\n  createIndex(\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions | Callback<string>,\n    callback?: Callback<string>\n  ): Promise<string> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new CreateIndexOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpec,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Creates multiple indexes in the collection, this method is only supported for\n   * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n   * error.\n   *\n   * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.\n   * Index specifications are defined {@link http://docs.mongodb.org/manual/reference/command/createIndexes/| here}.\n   *\n   * @param indexSpecs - An array of index specifications to be created\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   *\n   * @example\n   * ```js\n   * const collection = client.db('foo').collection('bar');\n   * await collection.createIndexes([\n   *   // Simple index on field fizz\n   *   {\n   *     key: { fizz: 1 },\n   *   }\n   *   // wildcard index\n   *   {\n   *     key: { '$**': 1 }\n   *   },\n   *   // named index on darmok and jalad\n   *   {\n   *     key: { darmok: 1, jalad: -1 }\n   *     name: 'tanagra'\n   *   }\n   * ]);\n   * ```\n   */\n  createIndexes(indexSpecs: IndexDescription[]): Promise<string[]>;\n  createIndexes(indexSpecs: IndexDescription[], callback: Callback<string[]>): void;\n  createIndexes(indexSpecs: IndexDescription[], options: CreateIndexesOptions): Promise<string[]>;\n  createIndexes(\n    indexSpecs: IndexDescription[],\n    options: CreateIndexesOptions,\n    callback: Callback<string[]>\n  ): void;\n  createIndexes(\n    indexSpecs: IndexDescription[],\n    options?: CreateIndexesOptions | Callback<string[]>,\n    callback?: Callback<string[]>\n  ): Promise<string[]> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ? Object.assign({}, options) : {};\n    if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n\n    return executeOperation(\n      getTopology(this),\n      new CreateIndexesOperation(\n        this as TODO_NODE_3286,\n        this.collectionName,\n        indexSpecs,\n        resolveOptions(this, options)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Drops an index from this collection.\n   *\n   * @param indexName - Name of the index to drop.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  dropIndex(indexName: string): Promise<Document>;\n  dropIndex(indexName: string, callback: Callback<Document>): void;\n  dropIndex(indexName: string, options: DropIndexesOptions): Promise<Document>;\n  dropIndex(indexName: string, options: DropIndexesOptions, callback: Callback<Document>): void;\n  dropIndex(\n    indexName: string,\n    options?: DropIndexesOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = resolveOptions(this, options);\n\n    // Run only against primary\n    options.readPreference = ReadPreference.primary;\n\n    return executeOperation(\n      getTopology(this),\n      new DropIndexOperation(this as TODO_NODE_3286, indexName, options),\n      callback\n    );\n  }\n\n  /**\n   * Drops all indexes from this collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  dropIndexes(): Promise<Document>;\n  dropIndexes(callback: Callback<Document>): void;\n  dropIndexes(options: DropIndexesOptions): Promise<Document>;\n  dropIndexes(options: DropIndexesOptions, callback: Callback<Document>): void;\n  dropIndexes(\n    options?: DropIndexesOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new DropIndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n  listIndexes(options?: ListIndexesOptions): ListIndexesCursor {\n    return new ListIndexesCursor(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /**\n   * Checks if one or more indexes exist on the collection, fails on first non-existing index\n   *\n   * @param indexes - One or more index names to check.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  indexExists(indexes: string | string[]): Promise<boolean>;\n  indexExists(indexes: string | string[], callback: Callback<boolean>): void;\n  indexExists(indexes: string | string[], options: IndexInformationOptions): Promise<boolean>;\n  indexExists(\n    indexes: string | string[],\n    options: IndexInformationOptions,\n    callback: Callback<boolean>\n  ): void;\n  indexExists(\n    indexes: string | string[],\n    options?: IndexInformationOptions | Callback<boolean>,\n    callback?: Callback<boolean>\n  ): Promise<boolean> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new IndexExistsOperation(this as TODO_NODE_3286, indexes, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Retrieves this collections index info.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  indexInformation(): Promise<Document>;\n  indexInformation(callback: Callback<Document>): void;\n  indexInformation(options: IndexInformationOptions): Promise<Document>;\n  indexInformation(options: IndexInformationOptions, callback: Callback<Document>): void;\n  indexInformation(\n    options?: IndexInformationOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new IndexInformationOperation(this.s.db, this.collectionName, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Gets an estimate of the count of documents in a collection using collection metadata.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  estimatedDocumentCount(): Promise<number>;\n  estimatedDocumentCount(callback: Callback<number>): void;\n  estimatedDocumentCount(options: EstimatedDocumentCountOptions): Promise<number>;\n  estimatedDocumentCount(options: EstimatedDocumentCountOptions, callback: Callback<number>): void;\n  estimatedDocumentCount(\n    options?: EstimatedDocumentCountOptions | Callback<number>,\n    callback?: Callback<number>\n  ): Promise<number> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    return executeOperation(\n      getTopology(this),\n      new EstimatedDocumentCountOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Gets the number of documents matching the filter.\n   * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}\n   * the following query operators must be replaced:\n   *\n   * | Operator | Replacement |\n   * | -------- | ----------- |\n   * | `$where`   | [`$expr`][1] |\n   * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n   * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n   *\n   * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   *\n   * @param filter - The filter for the count\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   *\n   * @see https://docs.mongodb.com/manual/reference/operator/query/expr/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n   * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n   * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n   */\n  countDocuments(): Promise<number>;\n  countDocuments(callback: Callback<number>): void;\n  countDocuments(filter: Filter<TSchema>): Promise<number>;\n  countDocuments(callback: Callback<number>): void;\n  countDocuments(filter: Filter<TSchema>, options: CountDocumentsOptions): Promise<number>;\n  countDocuments(\n    filter: Filter<TSchema>,\n    options: CountDocumentsOptions,\n    callback: Callback<number>\n  ): void;\n  countDocuments(filter: Filter<TSchema>, callback: Callback<number>): void;\n  countDocuments(\n    filter?: Document | CountDocumentsOptions | Callback<number>,\n    options?: CountDocumentsOptions | Callback<number>,\n    callback?: Callback<number>\n  ): Promise<number> | void {\n    if (typeof filter === 'undefined') {\n      (filter = {}), (options = {}), (callback = undefined);\n    } else if (typeof filter === 'function') {\n      (callback = filter as Callback<number>), (filter = {}), (options = {});\n    } else {\n      if (arguments.length === 2) {\n        if (typeof options === 'function') (callback = options), (options = {});\n      }\n    }\n\n    filter ??= {};\n    return executeOperation(\n      getTopology(this),\n      new CountDocumentsOperation(\n        this as TODO_NODE_3286,\n        filter as Document,\n        resolveOptions(this, options as CountDocumentsOptions)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * The distinct command returns a list of distinct values for the given key across a collection.\n   *\n   * @param key - Field of the document to find distinct values for\n   * @param filter - The filter for filtering the set of documents to which we apply the distinct filter.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    callback: Callback<Array<Flatten<WithId<TSchema>[Key]>>>\n  ): void;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    callback: Callback<Array<Flatten<WithId<TSchema>[Key]>>>\n  ): void;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    options: DistinctOptions\n  ): Promise<Array<Flatten<WithId<TSchema>[Key]>>>;\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter: Filter<TSchema>,\n    options: DistinctOptions,\n    callback: Callback<Array<Flatten<WithId<TSchema>[Key]>>>\n  ): void;\n\n  // Embedded documents overload\n  distinct(key: string): Promise<any[]>;\n  distinct(key: string, callback: Callback<any[]>): void;\n  distinct(key: string, filter: Filter<TSchema>): Promise<any[]>;\n  distinct(key: string, filter: Filter<TSchema>, callback: Callback<any[]>): void;\n  distinct(key: string, filter: Filter<TSchema>, options: DistinctOptions): Promise<any[]>;\n  distinct(\n    key: string,\n    filter: Filter<TSchema>,\n    options: DistinctOptions,\n    callback: Callback<any[]>\n  ): void;\n  // Implementation\n  distinct<Key extends keyof WithId<TSchema>>(\n    key: Key,\n    filter?: Filter<TSchema> | DistinctOptions | Callback<any[]>,\n    options?: DistinctOptions | Callback<any[]>,\n    callback?: Callback<any[]>\n  ): Promise<any[]> | void {\n    if (typeof filter === 'function') {\n      (callback = filter as Callback<any[]>), (filter = {}), (options = {});\n    } else {\n      if (arguments.length === 3 && typeof options === 'function') {\n        (callback = options), (options = {});\n      }\n    }\n\n    filter ??= {};\n    return executeOperation(\n      getTopology(this),\n      new DistinctOperation(\n        this as TODO_NODE_3286,\n        key as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options as DistinctOptions)\n      ),\n      callback\n    );\n  }\n\n  /**\n   * Retrieve all the indexes on the collection.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  indexes(): Promise<Document>;\n  indexes(callback: Callback<Document>): void;\n  indexes(options: IndexInformationOptions): Promise<Document>;\n  indexes(options: IndexInformationOptions, callback: Callback<Document>): void;\n  indexes(\n    options?: IndexInformationOptions | Callback<Document>,\n    callback?: Callback<Document>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new IndexesOperation(this as TODO_NODE_3286, resolveOptions(this, options)),\n      callback\n    );\n  }\n\n  /**\n   * Get all the collection statistics.\n   *\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  stats(): Promise<CollStats>;\n  stats(callback: Callback<CollStats>): void;\n  stats(options: CollStatsOptions): Promise<CollStats>;\n  stats(options: CollStatsOptions, callback: Callback<CollStats>): void;\n  stats(\n    options?: CollStatsOptions | Callback<CollStats>,\n    callback?: Callback<CollStats>\n  ): Promise<CollStats> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return executeOperation(\n      getTopology(this),\n      new CollStatsOperation(this as TODO_NODE_3286, options),\n      callback\n    );\n  }\n\n  /**\n   * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to remove\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOneAndDelete(filter: Filter<TSchema>): Promise<ModifyResult<TSchema>>;\n  findOneAndDelete(\n    filter: Filter<TSchema>,\n    options: FindOneAndDeleteOptions\n  ): Promise<ModifyResult<TSchema>>;\n  findOneAndDelete(filter: Filter<TSchema>, callback: Callback<ModifyResult<TSchema>>): void;\n  findOneAndDelete(\n    filter: Filter<TSchema>,\n    options: FindOneAndDeleteOptions,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndDelete(\n    filter: Filter<TSchema>,\n    options?: FindOneAndDeleteOptions | Callback<ModifyResult<TSchema>>,\n    callback?: Callback<ModifyResult<TSchema>>\n  ): Promise<Document> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new FindOneAndDeleteOperation(\n        this as TODO_NODE_3286,\n        filter,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to replace\n   * @param replacement - The Document that replaces the matching document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOneAndReplace(filter: Filter<TSchema>, replacement: Document): Promise<ModifyResult<TSchema>>;\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: Document,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: Document,\n    options: FindOneAndReplaceOptions\n  ): Promise<ModifyResult<TSchema>>;\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: Document,\n    options: FindOneAndReplaceOptions,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndReplace(\n    filter: Filter<TSchema>,\n    replacement: Document,\n    options?: FindOneAndReplaceOptions | Callback<ModifyResult<TSchema>>,\n    callback?: Callback<ModifyResult<TSchema>>\n  ): Promise<ModifyResult<TSchema>> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new FindOneAndReplaceOperation(\n        this as TODO_NODE_3286,\n        filter,\n        replacement,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n   *\n   * @param filter - The filter used to select the document to update\n   * @param update - Update operations to be performed on the document\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>\n  ): Promise<ModifyResult<TSchema>>;\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: FindOneAndUpdateOptions\n  ): Promise<ModifyResult<TSchema>>;\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: FindOneAndUpdateOptions,\n    callback: Callback<ModifyResult<TSchema>>\n  ): void;\n  findOneAndUpdate(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: FindOneAndUpdateOptions | Callback<ModifyResult<TSchema>>,\n    callback?: Callback<ModifyResult<TSchema>>\n  ): Promise<ModifyResult<TSchema>> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    return executeOperation(\n      getTopology(this),\n      new FindOneAndUpdateOperation(\n        this as TODO_NODE_3286,\n        filter,\n        update,\n        resolveOptions(this, options)\n      ) as TODO_NODE_3286,\n      callback\n    );\n  }\n\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n  aggregate<T = TSchema>(\n    pipeline: Document[] = [],\n    options?: AggregateOptions\n  ): AggregationCursor<T> {\n    if (arguments.length > 2) {\n      throw new MongoDriverError('Third parameter to `collection.aggregate()` must be undefined');\n    }\n    if (!Array.isArray(pipeline)) {\n      throw new MongoDriverError('`pipeline` parameter must be an array of aggregation stages');\n    }\n    if (typeof options === 'function') {\n      throw new MongoDriverError('`options` parameter must not be function');\n    }\n\n    return new AggregationCursor(\n      this as TODO_NODE_3286,\n      getTopology(this),\n      this.s.namespace,\n      pipeline,\n      resolveOptions(this, options)\n    );\n  }\n\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @since 3.0.0\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n  watch<TLocal = TSchema>(\n    pipeline: Document[] = [],\n    options: ChangeStreamOptions = {}\n  ): ChangeStream<TLocal> {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new ChangeStream<TLocal>(this, pipeline, resolveOptions(this, options));\n  }\n\n  /**\n   * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n   *\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>\n  ): Promise<Document | Document[]>;\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    callback: Callback<Document | Document[]>\n  ): void;\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    options: MapReduceOptions<TKey, TValue>\n  ): Promise<Document | Document[]>;\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    options: MapReduceOptions<TKey, TValue>,\n    callback: Callback<Document | Document[]>\n  ): void;\n  mapReduce<TKey = any, TValue = any>(\n    map: string | MapFunction<TSchema>,\n    reduce: string | ReduceFunction<TKey, TValue>,\n    options?: MapReduceOptions<TKey, TValue> | Callback<Document | Document[]>,\n    callback?: Callback<Document | Document[]>\n  ): Promise<Document | Document[]> | void {\n    if ('function' === typeof options) (callback = options), (options = {});\n    // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n    // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n    if (options?.out == null) {\n      throw new MongoDriverError(\n        'the out option parameter must be defined, see mongodb docs for possible values'\n      );\n    }\n\n    if ('function' === typeof map) {\n      map = map.toString();\n    }\n\n    if ('function' === typeof reduce) {\n      reduce = reduce.toString();\n    }\n\n    if ('function' === typeof options.finalize) {\n      options.finalize = options.finalize.toString();\n    }\n\n    return executeOperation(\n      getTopology(this),\n      new MapReduceOperation(\n        this as TODO_NODE_3286,\n        map,\n        reduce,\n        resolveOptions(this, options) as TODO_NODE_3286\n      ),\n      callback\n    );\n  }\n\n  /** Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */\n  initializeUnorderedBulkOp(options?: BulkWriteOptions): UnorderedBulkOperation {\n    return new UnorderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /** Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types. */\n  initializeOrderedBulkOp(options?: BulkWriteOptions): OrderedBulkOperation {\n    return new OrderedBulkOperation(this as TODO_NODE_3286, resolveOptions(this, options));\n  }\n\n  /** Get the db scoped logger */\n  getLogger(): Logger {\n    return this.s.db.s.logger;\n  }\n\n  get logger(): Logger {\n    return this.s.db.s.logger;\n  }\n\n  /**\n   * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @deprecated Use insertOne, insertMany or bulkWrite instead.\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  insert(\n    docs: OptionalId<TSchema>[],\n    options: BulkWriteOptions,\n    callback: Callback<InsertManyResult<TSchema>>\n  ): Promise<InsertManyResult<TSchema>> | void {\n    emitWarningOnce(\n      'collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.'\n    );\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || { ordered: false };\n    docs = !Array.isArray(docs) ? [docs] : docs;\n\n    if (options.keepGoing === true) {\n      options.ordered = false;\n    }\n\n    return this.insertMany(docs, options, callback);\n  }\n\n  /**\n   * Updates documents.\n   *\n   * @deprecated use updateOne, updateMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  update(\n    selector: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options: UpdateOptions,\n    callback: Callback<Document>\n  ): Promise<UpdateResult> | void {\n    emitWarningOnce(\n      'collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.'\n    );\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return this.updateMany(selector, update, options, callback);\n  }\n\n  /**\n   * Remove documents.\n   *\n   * @deprecated use deleteOne, deleteMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  remove(\n    selector: Filter<TSchema>,\n    options: DeleteOptions,\n    callback: Callback\n  ): Promise<DeleteResult> | void {\n    emitWarningOnce(\n      'collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.'\n    );\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    return this.deleteMany(selector, options, callback);\n  }\n\n  /**\n   * An estimated count of matching documents in the db to a filter.\n   *\n   * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n   * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.\n   * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.\n   *\n   * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead\n   *\n   * @param filter - The filter for the count.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  count(): Promise<number>;\n  count(callback: Callback<number>): void;\n  count(filter: Filter<TSchema>): Promise<number>;\n  count(filter: Filter<TSchema>, callback: Callback<number>): void;\n  count(filter: Filter<TSchema>, options: CountOptions): Promise<number>;\n  count(\n    filter: Filter<TSchema>,\n    options: CountOptions,\n    callback: Callback<number>\n  ): Promise<number> | void;\n  count(\n    filter?: Filter<TSchema> | CountOptions | Callback<number>,\n    options?: CountOptions | Callback<number>,\n    callback?: Callback<number>\n  ): Promise<number> | void {\n    if (typeof filter === 'function') {\n      (callback = filter as Callback<number>), (filter = {}), (options = {});\n    } else {\n      if (typeof options === 'function') (callback = options), (options = {});\n    }\n\n    filter ??= {};\n    return executeOperation(\n      getTopology(this),\n      new CountDocumentsOperation(this as TODO_NODE_3286, filter, resolveOptions(this, options)),\n      callback\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}