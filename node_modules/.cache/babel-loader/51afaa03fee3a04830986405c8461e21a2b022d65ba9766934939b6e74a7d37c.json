{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesCursor = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\nconst common_functions_1 = require(\"./common_functions\");\nconst operation_1 = require(\"./operation\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst read_preference_1 = require(\"../read_preference\");\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\nconst execute_operation_1 = require(\"./execute_operation\");\nconst LIST_INDEXES_WIRE_VERSION = 3;\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation',\n// text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion',\n// 2d-sphere indexes\n'2dsphereIndexVersion',\n// 2d indexes\n'bits', 'min', 'max',\n// geoHaystack Indexes\n'bucketSize',\n// wildcard indexes\n'wildcardProjection']);\nfunction makeIndexSpec(indexSpec, options) {\n  const indexParameters = utils_1.parseIndexOptions(indexSpec);\n  // Generate the index name\n  const name = typeof options.name === 'string' ? options.name : indexParameters.name;\n  // Set up the index\n  const finalIndexSpec = {\n    name,\n    key: indexParameters.fieldHash\n  };\n  // merge valid index options into the index spec\n  for (const optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n  return finalIndexSpec;\n}\n/** @internal */\nclass IndexesOperation extends operation_1.AbstractOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    common_functions_1.indexInformation(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n}\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\nclass CreateIndexesOperation extends command_1.CommandOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionName = collectionName;\n    this.indexes = indexes;\n  }\n  execute(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = utils_1.maxWireVersion(server);\n    // Ensure we generate the correct name if the parameter is not set\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(new error_1.MongoDriverError(`Server ${server.name}, which reports wire version ${serverWireVersion}, ` + 'does not support collation'));\n        return;\n      }\n      if (indexes[i].name == null) {\n        const keys = [];\n        for (const name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        }\n        // Set the name\n        indexes[i].name = keys.join('_');\n      }\n    }\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoDriverError('`commitQuorum` option for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n}\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n  execute(server, session, callback) {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n}\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n  execute(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n      super.execute(server, session, callback);\n    });\n  }\n}\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\nclass DropIndexOperation extends command_1.CommandOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n  execute(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommand(server, session, cmd, callback);\n  }\n}\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n  execute(server, session, callback) {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n}\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\nclass ListIndexesOperation extends command_1.CommandOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n  execute(server, session, callback) {\n    const serverWireVersion = utils_1.maxWireVersion(server);\n    if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {\n      const systemIndexesNS = this.collectionNamespace.withCollection('system.indexes');\n      const collectionNS = this.collectionNamespace.toString();\n      server.query(systemIndexesNS, {\n        query: {\n          ns: collectionNS\n        }\n      }, {\n        ...this.options,\n        readPreference: this.readPreference\n      }, callback);\n      return;\n    }\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    super.executeCommand(server, session, {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    }, callback);\n  }\n}\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @public */\nclass ListIndexesCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(collection, options) {\n    super(utils_1.getTopology(collection), collection.s.namespace, options);\n    this.parent = collection;\n    this.options = options;\n  }\n  clone() {\n    return new ListIndexesCursor(this.parent, {\n      ...this.options,\n      ...this.cursorOptions\n    });\n  }\n  /** @internal */\n  _initialize(session, callback) {\n    const operation = new ListIndexesOperation(this.parent, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    execute_operation_1.executeOperation(utils_1.getTopology(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err);\n      // TODO: NODE-2882\n      callback(undefined, {\n        server: operation.server,\n        session,\n        response\n      });\n    });\n  }\n}\nexports.ListIndexesCursor = ListIndexesCursor;\n/** @internal */\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    common_functions_1.indexInformation(coll.s.db, coll.collectionName, {\n      ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err);\n      // Let's check for the index names\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\n      // Check in list of indexes\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      }\n      // All keys found return true\n      return callback(undefined, true);\n    });\n  }\n}\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.name = name;\n  }\n  execute(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    common_functions_1.indexInformation(db, name, {\n      ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n}\nexports.IndexInformationOperation = IndexInformationOperation;\noperation_1.defineAspects(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);\noperation_1.defineAspects(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\noperation_1.defineAspects(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"names":["common_functions_1","require","operation_1","error_1","utils_1","command_1","read_preference_1","abstract_cursor_1","execute_operation_1","LIST_INDEXES_WIRE_VERSION","VALID_INDEX_OPTIONS","Set","makeIndexSpec","indexSpec","options","indexParameters","parseIndexOptions","name","finalIndexSpec","key","fieldHash","optionName","has","IndexesOperation","AbstractOperation","constructor","collection","execute","server","session","callback","coll","indexInformation","s","db","collectionName","full","readPreference","exports","CreateIndexesOperation","CommandOperation","parent","indexes","serverWireVersion","maxWireVersion","i","length","collation","MongoDriverError","keys","push","join","cmd","createIndexes","commitQuorum","undefined","executeCommand","err","indexNames","map","index","CreateIndexOperation","EnsureIndexOperation","ReadPreference","primary","indexName","cursor","listIndexes","toArray","code","MONGODB_ERROR_CODES","NamespaceNotFound","Array","isArray","some","DropIndexOperation","dropIndexes","DropIndexesOperation","ListIndexesOperation","collectionNamespace","namespace","systemIndexesNS","withCollection","collectionNS","toString","query","ns","batchSize","ListIndexesCursor","AbstractCursor","getTopology","clone","cursorOptions","_initialize","operation","executeOperation","response","IndexExistsOperation","IndexInformationOperation","defineAspects","Aspect","READ_OPERATION","RETRYABLE","WRITE_OPERATION"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\operations\\indexes.ts"],"sourcesContent":["import { indexInformation, IndexInformationOptions } from './common_functions';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\nimport { MONGODB_ERROR_CODES, MongoDriverError, MongoServerError } from '../error';\nimport {\n  maxWireVersion,\n  parseIndexOptions,\n  MongoDBNamespace,\n  Callback,\n  getTopology\n} from '../utils';\nimport {\n  CommandOperation,\n  CommandOperationOptions,\n  OperationParent,\n  CollationOptions\n} from './command';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Db } from '../db';\nimport { AbstractCursor } from '../cursor/abstract_cursor';\nimport type { ClientSession } from '../sessions';\nimport { executeOperation, ExecutionResult } from './execute_operation';\nimport type { OneOrMore } from '../mongo_types';\n\nconst LIST_INDEXES_WIRE_VERSION = 3;\nconst VALID_INDEX_OPTIONS = new Set([\n  'background',\n  'unique',\n  'name',\n  'partialFilterExpression',\n  'sparse',\n  'hidden',\n  'expireAfterSeconds',\n  'storageEngine',\n  'collation',\n\n  // text indexes\n  'weights',\n  'default_language',\n  'language_override',\n  'textIndexVersion',\n\n  // 2d-sphere indexes\n  '2dsphereIndexVersion',\n\n  // 2d indexes\n  'bits',\n  'min',\n  'max',\n\n  // geoHaystack Indexes\n  'bucketSize',\n\n  // wildcard indexes\n  'wildcardProjection'\n]);\n\n/** @public */\nexport type IndexDirection = -1 | 1 | '2d' | '2dsphere' | 'text' | 'geoHaystack' | number;\n\n/** @public */\nexport type IndexSpecification = OneOrMore<\n  | string\n  | [string, IndexDirection]\n  | { [key: string]: IndexDirection }\n  | [string, IndexDirection][]\n  | { [key: string]: IndexDirection }[]\n>;\n\n/** @public */\nexport interface IndexDescription {\n  collation?: CollationOptions;\n  name?: string;\n  key: Document;\n}\n\n/** @public */\nexport interface CreateIndexesOptions extends CommandOperationOptions {\n  /** Creates the index in the background, yielding whenever possible. */\n  background?: boolean;\n  /** Creates an unique index. */\n  unique?: boolean;\n  /** Override the autogenerated index name (useful if the resulting name is larger than 128 bytes) */\n  name?: string;\n  /** Creates a partial index based on the given filter object (MongoDB 3.2 or higher) */\n  partialFilterExpression?: Document;\n  /** Creates a sparse index. */\n  sparse?: boolean;\n  /** Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher) */\n  expireAfterSeconds?: number;\n  storageEngine?: Document;\n  /** (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes. */\n  commitQuorum?: number | string;\n  // text indexes\n  weights?: Document;\n  default_language?: string;\n  language_override?: string;\n  textIndexVersion?: number;\n  // 2d-sphere indexes\n  '2dsphereIndexVersion'?: number;\n  // 2d indexes\n  bits?: number;\n  /** For geospatial indexes set the lower bound for the co-ordinates. */\n  min?: number;\n  /** For geospatial indexes set the high bound for the co-ordinates. */\n  max?: number;\n  // geoHaystack Indexes\n  bucketSize?: number;\n  // wildcard indexes\n  wildcardProjection?: Document;\n}\n\nfunction makeIndexSpec(indexSpec: IndexSpecification, options: any): IndexDescription {\n  const indexParameters = parseIndexOptions(indexSpec);\n\n  // Generate the index name\n  const name = typeof options.name === 'string' ? options.name : indexParameters.name;\n\n  // Set up the index\n  const finalIndexSpec: Document = { name, key: indexParameters.fieldHash };\n\n  // merge valid index options into the index spec\n  for (const optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n\n  return finalIndexSpec as IndexDescription;\n}\n\n/** @internal */\nexport class IndexesOperation extends AbstractOperation<Document> {\n  options: IndexInformationOptions;\n  collection: Collection;\n\n  constructor(collection: Collection, options: IndexInformationOptions) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<Document>): void {\n    const coll = this.collection;\n    const options = this.options;\n\n    indexInformation(\n      coll.s.db,\n      coll.collectionName,\n      { full: true, ...options, readPreference: this.readPreference, session },\n      callback\n    );\n  }\n}\n\n/** @internal */\nexport class CreateIndexesOperation<\n  T extends string | string[] = string[]\n> extends CommandOperation<T> {\n  options: CreateIndexesOptions;\n  collectionName: string;\n  indexes: IndexDescription[];\n\n  constructor(\n    parent: OperationParent,\n    collectionName: string,\n    indexes: IndexDescription[],\n    options?: CreateIndexesOptions\n  ) {\n    super(parent, options);\n\n    this.options = options ?? {};\n    this.collectionName = collectionName;\n\n    this.indexes = indexes;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<T>): void {\n    const options = this.options;\n    const indexes = this.indexes;\n\n    const serverWireVersion = maxWireVersion(server);\n\n    // Ensure we generate the correct name if the parameter is not set\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(\n          new MongoDriverError(\n            `Server ${server.name}, which reports wire version ${serverWireVersion}, ` +\n              'does not support collation'\n          )\n        );\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (const name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        }\n\n        // Set the name\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd: Document = { createIndexes: this.collectionName, indexes };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(\n          new MongoDriverError(\n            '`commitQuorum` option for `createIndexes` not supported on servers < 4.4'\n          )\n        );\n        return;\n      }\n      cmd.commitQuorum = options.commitQuorum;\n    }\n\n    // collation is set on each index, it should not be defined at the root\n    this.options.collation = undefined;\n\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames as T);\n    });\n  }\n}\n\n/** @internal */\nexport class CreateIndexOperation extends CreateIndexesOperation<string> {\n  constructor(\n    parent: OperationParent,\n    collectionName: string,\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ) {\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n  execute(server: Server, session: ClientSession, callback: Callback<string>): void {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n}\n\n/** @internal */\nexport class EnsureIndexOperation extends CreateIndexOperation {\n  db: Db;\n  collectionName: string;\n\n  constructor(\n    db: Db,\n    collectionName: string,\n    indexSpec: IndexSpecification,\n    options?: CreateIndexesOptions\n  ) {\n    super(db, collectionName, indexSpec, options);\n\n    this.readPreference = ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback): void {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({ session });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && (err as MongoServerError).code !== MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n}\n\n/** @public */\nexport type DropIndexesOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropIndexOperation extends CommandOperation<Document> {\n  options: DropIndexesOptions;\n  collection: Collection;\n  indexName: string;\n\n  constructor(collection: Collection, indexName: string, options?: DropIndexesOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<Document>): void {\n    const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };\n    super.executeCommand(server, session, cmd, callback);\n  }\n}\n\n/** @internal */\nexport class DropIndexesOperation extends DropIndexOperation {\n  constructor(collection: Collection, options: DropIndexesOptions) {\n    super(collection, '*', options);\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback): void {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n}\n\n/** @public */\nexport interface ListIndexesOptions extends CommandOperationOptions {\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\n  batchSize?: number;\n}\n\n/** @internal */\nexport class ListIndexesOperation extends CommandOperation<Document> {\n  options: ListIndexesOptions;\n  collectionNamespace: MongoDBNamespace;\n\n  constructor(collection: Collection, options?: ListIndexesOptions) {\n    super(collection, options);\n\n    this.options = options ?? {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<Document>): void {\n    const serverWireVersion = maxWireVersion(server);\n    if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {\n      const systemIndexesNS = this.collectionNamespace.withCollection('system.indexes');\n      const collectionNS = this.collectionNamespace.toString();\n\n      server.query(\n        systemIndexesNS,\n        { query: { ns: collectionNS } },\n        { ...this.options, readPreference: this.readPreference },\n        callback\n      );\n      return;\n    }\n\n    const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};\n    super.executeCommand(\n      server,\n      session,\n      { listIndexes: this.collectionNamespace.collection, cursor },\n      callback\n    );\n  }\n}\n\n/** @public */\nexport class ListIndexesCursor extends AbstractCursor {\n  parent: Collection;\n  options?: ListIndexesOptions;\n\n  constructor(collection: Collection, options?: ListIndexesOptions) {\n    super(getTopology(collection), collection.s.namespace, options);\n    this.parent = collection;\n    this.options = options;\n  }\n\n  clone(): ListIndexesCursor {\n    return new ListIndexesCursor(this.parent, {\n      ...this.options,\n      ...this.cursorOptions\n    });\n  }\n\n  /** @internal */\n  _initialize(session: ClientSession | undefined, callback: Callback<ExecutionResult>): void {\n    const operation = new ListIndexesOperation(this.parent, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n\n    executeOperation(getTopology(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err);\n\n      // TODO: NODE-2882\n      callback(undefined, { server: operation.server, session, response });\n    });\n  }\n}\n\n/** @internal */\nexport class IndexExistsOperation extends AbstractOperation<boolean> {\n  options: IndexInformationOptions;\n  collection: Collection;\n  indexes: string | string[];\n\n  constructor(\n    collection: Collection,\n    indexes: string | string[],\n    options: IndexInformationOptions\n  ) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<boolean>): void {\n    const coll = this.collection;\n    const indexes = this.indexes;\n\n    indexInformation(\n      coll.s.db,\n      coll.collectionName,\n      { ...this.options, readPreference: this.readPreference, session },\n      (err, indexInformation) => {\n        // If we have an error return\n        if (err != null) return callback(err);\n        // Let's check for the index names\n        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\n        // Check in list of indexes\n        for (let i = 0; i < indexes.length; i++) {\n          if (indexInformation[indexes[i]] == null) {\n            return callback(undefined, false);\n          }\n        }\n\n        // All keys found return true\n        return callback(undefined, true);\n      }\n    );\n  }\n}\n\n/** @internal */\nexport class IndexInformationOperation extends AbstractOperation<Document> {\n  options: IndexInformationOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options?: IndexInformationOptions) {\n    super(options);\n    this.options = options ?? {};\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<Document>): void {\n    const db = this.db;\n    const name = this.name;\n\n    indexInformation(\n      db,\n      name,\n      { ...this.options, readPreference: this.readPreference, session },\n      callback\n    );\n  }\n}\n\ndefineAspects(ListIndexesOperation, [Aspect.READ_OPERATION, Aspect.RETRYABLE]);\ndefineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(CreateIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(EnsureIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropIndexOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropIndexesOperation, [Aspect.WRITE_OPERATION]);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}