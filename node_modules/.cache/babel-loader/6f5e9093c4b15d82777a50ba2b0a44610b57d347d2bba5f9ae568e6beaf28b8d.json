{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst utils_1 = require(\"../utils\");\nconst bson_1 = require(\"../bson\");\nconst sessions_1 = require(\"../sessions\");\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst stream_1 = require(\"stream\");\nconst read_concern_1 = require(\"../read_concern\");\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kTopology = Symbol('topology');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(topology, namespace, options = {}) {\n    super();\n    this[kTopology] = topology;\n    this[kNamespace] = namespace;\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...bson_1.pluckBSONSerializeOptions(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n    if (typeof options.comment !== 'undefined') {\n      this[kOptions].comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    }\n  }\n  get id() {\n    return this[kId];\n  }\n  /** @internal */\n  get topology() {\n    return this[kTopology];\n  }\n  /** @internal */\n  get server() {\n    return this[kServer];\n  }\n  get namespace() {\n    return this[kNamespace];\n  }\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this[kSession];\n  }\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n  get cursorOptions() {\n    return this[kOptions];\n  }\n  get closed() {\n    return this[kClosed];\n  }\n  get killed() {\n    return this[kKilled];\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n  }\n  [Symbol.asyncIterator]() {\n    return {\n      next: () => this.next().then(value => ({\n        value,\n        done: value === null\n      }))\n    };\n  }\n  stream(options) {\n    if (options === null || options === void 0 ? void 0 : options.transform) {\n      const transform = options.transform;\n      const readable = makeCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n    }\n    return makeCursorStream(this);\n  }\n  hasNext(callback) {\n    return utils_1.maybePromise(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(undefined, false);\n      }\n      if (this[kDocuments].length) {\n        return done(undefined, true);\n      }\n      next(this, true, (err, doc) => {\n        // FIXME(NODE):\n        if (err) return done(err);\n        if (doc) {\n          this[kDocuments].unshift(doc);\n          done(undefined, true);\n          return;\n        }\n        done(undefined, false);\n      });\n    });\n  }\n  next(callback) {\n    return utils_1.maybePromise(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoDriverError('Cursor is exhausted'));\n      }\n      next(this, true, done);\n    });\n  }\n  tryNext(callback) {\n    return utils_1.maybePromise(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoDriverError('Cursor is exhausted'));\n      }\n      next(this, false, done);\n    });\n  }\n  forEach(iterator, callback) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoDriverError('Missing required parameter `iterator`');\n    }\n    return utils_1.maybePromise(callback, done => {\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        next(this, true, (err, doc) => {\n          if (err || doc == null) return done(err);\n          let result;\n          // NOTE: no need to transform because `next` will do this automatically\n          try {\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n          } catch (error) {\n            return done(error);\n          }\n          if (result === false) return done();\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n          for (let i = 0; i < internalDocs.length; ++i) {\n            try {\n              result = iterator(transform ? transform(internalDocs[i]) : internalDocs[i] // TODO(NODE-3283): Improve transform typing\n              );\n            } catch (error) {\n              return done(error);\n            }\n            if (result === false) return done();\n          }\n          fetchDocs();\n        });\n      };\n      fetchDocs();\n    });\n  }\n  close(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    return utils_1.maybePromise(callback, done => {\n      const cursorId = this[kId];\n      const cursorNs = this[kNamespace];\n      const server = this[kServer];\n      const session = this[kSession];\n      if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n        if (needsToEmitClosed) {\n          this[kId] = bson_1.Long.ZERO;\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-expect-error\n          this.emit(AbstractCursor.CLOSE);\n        }\n        if (session && session.owner === this) {\n          return session.endSession(done);\n        }\n        return done();\n      }\n      this[kKilled] = true;\n      server.killCursors(cursorNs, [cursorId], {\n        ...bson_1.pluckBSONSerializeOptions(this[kOptions]),\n        session\n      }, () => {\n        if (session && session.owner === this) {\n          return session.endSession(() => {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-expect-error\n            this.emit(AbstractCursor.CLOSE);\n            done();\n          });\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        this.emit(AbstractCursor.CLOSE);\n        done();\n      });\n    });\n  }\n  toArray(callback) {\n    return utils_1.maybePromise(callback, done => {\n      const docs = [];\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        // NOTE: if we add a `nextBatch` then we should use it here\n        next(this, true, (err, doc) => {\n          if (err) return done(err);\n          if (doc == null) return done(undefined, docs);\n          // NOTE: no need to transform because `next` will do this automatically\n          docs.push(doc);\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = transform ? this[kDocuments].splice(0, this[kDocuments].length).map(transform) : this[kDocuments].splice(0, this[kDocuments].length); // TODO(NODE-3283): Improve transform typing\n          if (internalDocs) {\n            docs.push(...internalDocs);\n          }\n          fetchDocs();\n        });\n      };\n      fetchDocs();\n    });\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoDriverError(`flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoDriverError(`flag ${flag} must be a boolean value`);\n    }\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   * @remarks\n   *\n   * **NOTE:** adding a transform changes the return type of the iteration of this cursor, it **does not** return\n   * a new instance of a cursor. This means when calling map, you should always assign the result to a new\n   * variable. Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoDriverError('Invalid read preference: ' + readPreference);\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new error_1.MongoDriverError('maxTimeMS must be a number');\n    }\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoDriverError('Tailable cursors do not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoDriverError('batchSize requires an integer');\n    }\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n    this[kId] = undefined;\n    this[kDocuments] = [];\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false && !session.hasEnded) {\n        session.endSession();\n      }\n      this[kSession] = undefined;\n    }\n  }\n  /** @internal */\n  _getMore(batchSize, callback) {\n    const cursorId = this[kId];\n    const cursorNs = this[kNamespace];\n    const server = this[kServer];\n    if (cursorId == null) {\n      callback(new error_1.MongoDriverError('Unable to iterate cursor with no id'));\n      return;\n    }\n    if (server == null) {\n      callback(new error_1.MongoDriverError('Unable to iterate cursor without selected server'));\n      return;\n    }\n    server.getMore(cursorNs, cursorId, {\n      ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    }, callback);\n  }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nfunction nextDocument(cursor) {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n  const doc = cursor[kDocuments].shift();\n  if (doc) {\n    const transform = cursor[kTransform];\n    if (transform) {\n      return transform(doc);\n    }\n    return doc;\n  }\n  return null;\n}\nfunction next(cursor, blocking, callback) {\n  const cursorId = cursor[kId];\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    if (cursor[kSession] == null && cursor[kTopology].hasSessionSupport()) {\n      cursor[kSession] = cursor[kTopology].startSession({\n        owner: cursor,\n        explicit: false\n      });\n    }\n    cursor._initialize(cursor[kSession], (err, state) => {\n      if (state) {\n        const response = state.response;\n        cursor[kServer] = state.server;\n        cursor[kSession] = state.session;\n        if (response.cursor) {\n          cursor[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n          if (response.cursor.ns) {\n            cursor[kNamespace] = utils_1.ns(response.cursor.ns);\n          }\n          cursor[kDocuments] = response.cursor.firstBatch;\n        } else {\n          // NOTE: This is for support of older servers (<3.2) which do not use commands\n          cursor[kId] = typeof response.cursorId === 'number' ? bson_1.Long.fromNumber(response.cursorId) : response.cursorId;\n          cursor[kDocuments] = response.documents;\n        }\n        // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n        if (cursor[kId] == null) {\n          cursor[kId] = bson_1.Long.ZERO;\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n          cursor[kDocuments] = [state.response];\n        }\n      }\n      // the cursor is now initialized, even if an error occurred or it is dead\n      cursor[kInitialized] = true;\n      if (err || cursorIsDead(cursor)) {\n        return cleanupCursor(cursor, () => callback(err, nextDocument(cursor)));\n      }\n      next(cursor, blocking, callback);\n    });\n    return;\n  }\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, () => callback(undefined, null));\n  }\n  // otherwise need to call getMore\n  const batchSize = cursor[kOptions].batchSize || 1000;\n  cursor._getMore(batchSize, (err, response) => {\n    if (response) {\n      const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = cursorId;\n    }\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, () => callback(err, nextDocument(cursor)));\n    }\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n    next(cursor, blocking, callback);\n  });\n}\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\nfunction cleanupCursor(cursor, callback) {\n  if (cursor[kDocuments].length === 0) {\n    cursor[kClosed] = true;\n    cursor.emit(AbstractCursor.CLOSE);\n  }\n  const session = cursor[kSession];\n  if (session && session.owner === cursor) {\n    session.endSession(callback);\n  } else {\n    callback();\n  }\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoDriverError('Cursor is already initialized');\n  }\n}\nexports.assertUninitialized = assertUninitialized;\nfunction makeCursorStream(cursor) {\n  const readable = new stream_1.Readable({\n    objectMode: true,\n    autoDestroy: false,\n    highWaterMark: 1\n  });\n  let initialized = false;\n  let reading = false;\n  let needToClose = true; // NOTE: we must close the cursor if we never read from it, use `_construct` in future node versions\n  readable._read = function () {\n    if (initialized === false) {\n      needToClose = false;\n      initialized = true;\n    }\n    if (!reading) {\n      reading = true;\n      readNext();\n    }\n  };\n  readable._destroy = function (error, cb) {\n    if (needToClose) {\n      cursor.close(err => process.nextTick(cb, err || error));\n    } else {\n      cb(error);\n    }\n  };\n  function readNext() {\n    needToClose = false;\n    next(cursor, true, (err, result) => {\n      needToClose = err ? !cursor.closed : result !== null;\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          cursor.close();\n          return readable.push(null);\n        }\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight.\n        if (cursor.killed) {\n          return readable.push(null);\n        }\n        return readable.destroy(err);\n      }\n      if (result === null) {\n        readable.push(null);\n      } else if (readable.destroyed) {\n        cursor.close();\n      } else {\n        if (readable.push(result)) {\n          return readNext();\n        }\n        reading = false;\n      }\n    });\n  }\n  return readable;\n}","map":{"version":3,"names":["utils_1","require","bson_1","sessions_1","error_1","read_preference_1","stream_1","read_concern_1","mongo_types_1","kId","Symbol","kDocuments","kServer","kNamespace","kTopology","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","exports","CURSOR_FLAGS","AbstractCursor","TypedEventEmitter","constructor","topology","namespace","options","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","readConcern","ReadConcern","fromOptions","batchSize","comment","maxTimeMS","session","ClientSession","id","server","clientSession","cursorOptions","closed","killed","bufferedCount","length","readBufferedDocuments","number","splice","asyncIterator","next","then","value","done","stream","transform","readable","makeCursorStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","undefined","err","hasNext","maybePromise","Long","ZERO","doc","unshift","MongoDriverError","tryNext","forEach","iterator","fetchDocs","result","error","internalDocs","i","close","needsToEmitClosed","cursorId","cursorNs","isZero","emit","CLOSE","owner","endSession","killCursors","toArray","docs","push","map","addCursorFlag","flag","assertUninitialized","includes","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","rewind","explicit","hasEnded","_getMore","getMore","nextDocument","cursor","shift","blocking","hasSessionSupport","startSession","_initialize","state","response","fromNumber","ns","firstBatch","documents","cursorIsDead","cleanupCursor","nextBatch","Readable","autoDestroy","initialized","reading","needToClose","_read","readNext","_destroy","cb","process","nextTick","message","match","destroy","destroyed"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Callback, maybePromise, MongoDBNamespace, ns } from '../utils';\nimport { Long, Document, BSONSerializeOptions, pluckBSONSerializeOptions } from '../bson';\nimport { ClientSession } from '../sessions';\nimport { MongoDriverError } from '../error';\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { Topology } from '../sdam/topology';\nimport { Readable, Transform } from 'stream';\nimport type { ExecutionResult } from '../operations/execute_operation';\nimport { ReadConcern, ReadConcernLike } from '../read_concern';\nimport { TODO_NODE_3286, TypedEventEmitter } from '../mongo_types';\n\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kTopology = Symbol('topology');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public */\nexport interface CursorCloseOptions {\n  /** Bypass calling killCursors when closing the cursor. */\n  skipKillCursors?: boolean;\n}\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = typeof CURSOR_FLAGS[number];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  batchSize?: number;\n  maxTimeMS?: number;\n  comment?: Document | string;\n  tailable?: boolean;\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n  TSchema = any,\n  CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n> extends TypedEventEmitter<CursorEvents> {\n  /** @internal */\n  [kId]?: Long;\n  /** @internal */\n  [kSession]?: ClientSession;\n  /** @internal */\n  [kServer]?: Server;\n  /** @internal */\n  [kNamespace]: MongoDBNamespace;\n  /** @internal */\n  [kDocuments]: TSchema[];\n  /** @internal */\n  [kTopology]: Topology;\n  /** @internal */\n  [kTransform]?: (doc: TSchema) => Document;\n  /** @internal */\n  [kInitialized]: boolean;\n  /** @internal */\n  [kClosed]: boolean;\n  /** @internal */\n  [kKilled]: boolean;\n  /** @internal */\n  [kOptions]: InternalAbstractCursorOptions;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  constructor(\n    topology: Topology,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions = {}\n  ) {\n    super();\n\n    this[kTopology] = topology;\n    this[kNamespace] = namespace;\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options)\n    };\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n\n    if (typeof options.comment !== 'undefined') {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this[kSession] = options.session;\n    }\n  }\n\n  get id(): Long | undefined {\n    return this[kId];\n  }\n\n  /** @internal */\n  get topology(): Topology {\n    return this[kTopology];\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this[kServer];\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this[kNamespace];\n  }\n\n  get readPreference(): ReadPreference {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this[kOptions].readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession | undefined {\n    return this[kSession];\n  }\n\n  set session(clientSession: ClientSession | undefined) {\n    this[kSession] = clientSession;\n  }\n\n  /** @internal */\n  get cursorOptions(): InternalAbstractCursorOptions {\n    return this[kOptions];\n  }\n\n  get closed(): boolean {\n    return this[kClosed];\n  }\n\n  get killed(): boolean {\n    return this[kKilled];\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this[kDocuments].length;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): TSchema[] {\n    return this[kDocuments].splice(0, number ?? this[kDocuments].length);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<TSchema | null> {\n    return {\n      next: () => this.next<TSchema>().then(value => ({ value, done: value === null }))\n    };\n  }\n\n  stream(options?: CursorStreamOptions): Readable {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = makeCursorStream(this);\n\n      return readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n    }\n\n    return makeCursorStream(this);\n  }\n\n  hasNext(): Promise<boolean>;\n  hasNext(callback: Callback<boolean>): void;\n  hasNext(callback?: Callback<boolean>): Promise<boolean> | void {\n    return maybePromise(callback, done => {\n      if (this[kId] === Long.ZERO) {\n        return done(undefined, false);\n      }\n\n      if (this[kDocuments].length) {\n        return done(undefined, true);\n      }\n\n      next<any>(this, true, (err, doc) => {\n        // FIXME(NODE):\n        if (err) return done(err);\n\n        if (doc) {\n          this[kDocuments].unshift(doc);\n          done(undefined, true);\n          return;\n        }\n\n        done(undefined, false);\n      });\n    });\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  next<T = TSchema>(): Promise<T | null>;\n  next<T = TSchema>(callback: Callback<T | null>): void;\n  next<T = TSchema>(callback?: Callback<T | null>): Promise<T | null> | void {\n    return maybePromise(callback, done => {\n      if (this[kId] === Long.ZERO) {\n        return done(new MongoDriverError('Cursor is exhausted'));\n      }\n\n      next(this, true, done);\n    });\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  tryNext<T = TSchema>(): Promise<T | null>;\n  tryNext<T = TSchema>(callback: Callback<T | null>): void;\n  tryNext<T = TSchema>(callback?: Callback<T | null>): Promise<T | null> | void {\n    return maybePromise(callback, done => {\n      if (this[kId] === Long.ZERO) {\n        return done(new MongoDriverError('Cursor is exhausted'));\n      }\n\n      next(this, false, done);\n    });\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * @param iterator - The iteration callback.\n   * @param callback - The end callback.\n   */\n  forEach<T = TSchema>(iterator: (doc: T) => boolean | void): Promise<void>;\n  forEach<T = TSchema>(iterator: (doc: T) => boolean | void, callback: Callback<void>): void;\n  forEach<T = TSchema>(\n    iterator: (doc: T) => boolean | void,\n    callback?: Callback<void>\n  ): Promise<void> | void {\n    if (typeof iterator !== 'function') {\n      throw new MongoDriverError('Missing required parameter `iterator`');\n    }\n    return maybePromise(callback, done => {\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        next<T>(this, true, (err, doc) => {\n          if (err || doc == null) return done(err);\n          let result;\n          // NOTE: no need to transform because `next` will do this automatically\n          try {\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n          } catch (error) {\n            return done(error);\n          }\n\n          if (result === false) return done();\n\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n          for (let i = 0; i < internalDocs.length; ++i) {\n            try {\n              result = iterator(\n                (transform ? transform(internalDocs[i]) : internalDocs[i]) as T // TODO(NODE-3283): Improve transform typing\n              );\n            } catch (error) {\n              return done(error);\n            }\n            if (result === false) return done();\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n\n  close(): void;\n  close(callback: Callback): void;\n  close(options: CursorCloseOptions): Promise<void>;\n  close(options: CursorCloseOptions, callback: Callback): void;\n  close(options?: CursorCloseOptions | Callback, callback?: Callback): Promise<void> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n\n    return maybePromise(callback, done => {\n      const cursorId = this[kId];\n      const cursorNs = this[kNamespace];\n      const server = this[kServer];\n      const session = this[kSession];\n\n      if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n        if (needsToEmitClosed) {\n          this[kId] = Long.ZERO;\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-expect-error\n          this.emit(AbstractCursor.CLOSE);\n        }\n\n        if (session && session.owner === this) {\n          return session.endSession(done);\n        }\n\n        return done();\n      }\n\n      this[kKilled] = true;\n      server.killCursors(\n        cursorNs,\n        [cursorId],\n        { ...pluckBSONSerializeOptions(this[kOptions]), session },\n        () => {\n          if (session && session.owner === this) {\n            return session.endSession(() => {\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-expect-error\n              this.emit(AbstractCursor.CLOSE);\n              done();\n            });\n          }\n\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-expect-error\n          this.emit(AbstractCursor.CLOSE);\n          done();\n        }\n      );\n    });\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   *\n   * @param callback - The result callback.\n   */\n  toArray<T = TSchema>(): Promise<T[]>;\n  toArray<T = TSchema>(callback: Callback<T[]>): void;\n  toArray<T = TSchema>(callback?: Callback<T[]>): Promise<T[]> | void {\n    return maybePromise(callback, done => {\n      const docs: T[] = [];\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        // NOTE: if we add a `nextBatch` then we should use it here\n        next<T>(this, true, (err, doc) => {\n          if (err) return done(err);\n          if (doc == null) return done(undefined, docs);\n\n          // NOTE: no need to transform because `next` will do this automatically\n          docs.push(doc);\n\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = (transform\n            ? this[kDocuments].splice(0, this[kDocuments].length).map(transform)\n            : this[kDocuments].splice(0, this[kDocuments].length)) as T[]; // TODO(NODE-3283): Improve transform typing\n\n          if (internalDocs) {\n            docs.push(...internalDocs);\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    assertUninitialized(this);\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoDriverError(`flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoDriverError(`flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   * @remarks\n   *\n   * **NOTE:** adding a transform changes the return type of the iteration of this cursor, it **does not** return\n   * a new instance of a cursor. This means when calling map, you should always assign the result to a new\n   * variable. Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform] as (doc: TSchema) => TSchema; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return (this as unknown) as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    assertUninitialized(this);\n    if (readPreference instanceof ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoDriverError('Invalid read preference: ' + readPreference);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    assertUninitialized(this);\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new MongoDriverError('maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new MongoDriverError('Tailable cursors do not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoDriverError('batchSize requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = undefined;\n    this[kDocuments] = [];\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false && !session.hasEnded) {\n        session.endSession();\n      }\n\n      this[kSession] = undefined;\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  abstract _initialize(\n    session: ClientSession | undefined,\n    callback: Callback<ExecutionResult>\n  ): void;\n\n  /** @internal */\n  _getMore(batchSize: number, callback: Callback<Document>): void {\n    const cursorId = this[kId];\n    const cursorNs = this[kNamespace];\n    const server = this[kServer];\n\n    if (cursorId == null) {\n      callback(new MongoDriverError('Unable to iterate cursor with no id'));\n      return;\n    }\n\n    if (server == null) {\n      callback(new MongoDriverError('Unable to iterate cursor without selected server'));\n      return;\n    }\n\n    server.getMore(\n      cursorNs,\n      cursorId,\n      {\n        ...this[kOptions],\n        session: this[kSession],\n        batchSize\n      },\n      callback\n    );\n  }\n}\n\nfunction nextDocument<T>(cursor: AbstractCursor): T | null | undefined {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n\n  const doc = cursor[kDocuments].shift();\n  if (doc) {\n    const transform = cursor[kTransform];\n    if (transform) {\n      return transform(doc) as T;\n    }\n\n    return doc;\n  }\n\n  return null;\n}\n\nfunction next<T>(cursor: AbstractCursor, blocking: boolean, callback: Callback<T | null>): void {\n  const cursorId = cursor[kId];\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    if (cursor[kSession] == null && cursor[kTopology].hasSessionSupport()) {\n      cursor[kSession] = cursor[kTopology].startSession({ owner: cursor, explicit: false });\n    }\n\n    cursor._initialize(cursor[kSession], (err, state) => {\n      if (state) {\n        const response = state.response;\n        cursor[kServer] = state.server;\n        cursor[kSession] = state.session;\n\n        if (response.cursor) {\n          cursor[kId] =\n            typeof response.cursor.id === 'number'\n              ? Long.fromNumber(response.cursor.id)\n              : response.cursor.id;\n\n          if (response.cursor.ns) {\n            cursor[kNamespace] = ns(response.cursor.ns);\n          }\n\n          cursor[kDocuments] = response.cursor.firstBatch;\n        } else {\n          // NOTE: This is for support of older servers (<3.2) which do not use commands\n          cursor[kId] =\n            typeof response.cursorId === 'number'\n              ? Long.fromNumber(response.cursorId)\n              : response.cursorId;\n          cursor[kDocuments] = response.documents;\n        }\n\n        // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n        if (cursor[kId] == null) {\n          cursor[kId] = Long.ZERO;\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n          cursor[kDocuments] = [state.response as TODO_NODE_3286];\n        }\n      }\n\n      // the cursor is now initialized, even if an error occurred or it is dead\n      cursor[kInitialized] = true;\n\n      if (err || cursorIsDead(cursor)) {\n        return cleanupCursor(cursor, () => callback(err, nextDocument(cursor)));\n      }\n\n      next(cursor, blocking, callback);\n    });\n\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, () => callback(undefined, null));\n  }\n\n  // otherwise need to call getMore\n  const batchSize = cursor[kOptions].batchSize || 1000;\n  cursor._getMore(batchSize, (err, response) => {\n    if (response) {\n      const cursorId =\n        typeof response.cursor.id === 'number'\n          ? Long.fromNumber(response.cursor.id)\n          : response.cursor.id;\n\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = cursorId;\n    }\n\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, () => callback(err, nextDocument(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nfunction cursorIsDead(cursor: AbstractCursor): boolean {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nfunction cleanupCursor(cursor: AbstractCursor, callback: Callback): void {\n  if (cursor[kDocuments].length === 0) {\n    cursor[kClosed] = true;\n    cursor.emit(AbstractCursor.CLOSE);\n  }\n\n  const session = cursor[kSession];\n  if (session && session.owner === cursor) {\n    session.endSession(callback);\n  } else {\n    callback();\n  }\n}\n\n/** @internal */\nexport function assertUninitialized(cursor: AbstractCursor): void {\n  if (cursor[kInitialized]) {\n    throw new MongoDriverError('Cursor is already initialized');\n  }\n}\n\nfunction makeCursorStream<TSchema extends Document>(cursor: AbstractCursor<TSchema>) {\n  const readable = new Readable({\n    objectMode: true,\n    autoDestroy: false,\n    highWaterMark: 1\n  });\n\n  let initialized = false;\n  let reading = false;\n  let needToClose = true; // NOTE: we must close the cursor if we never read from it, use `_construct` in future node versions\n\n  readable._read = function () {\n    if (initialized === false) {\n      needToClose = false;\n      initialized = true;\n    }\n\n    if (!reading) {\n      reading = true;\n      readNext();\n    }\n  };\n\n  readable._destroy = function (error, cb) {\n    if (needToClose) {\n      cursor.close(err => process.nextTick(cb, err || error));\n    } else {\n      cb(error);\n    }\n  };\n\n  function readNext() {\n    needToClose = false;\n    next(cursor, true, (err, result) => {\n      needToClose = err ? !cursor.closed : result !== null;\n\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          cursor.close();\n          return readable.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight.\n        if (cursor.killed) {\n          return readable.push(null);\n        }\n\n        return readable.destroy(err);\n      }\n\n      if (result === null) {\n        readable.push(null);\n      } else if (readable.destroyed) {\n        cursor.close();\n      } else {\n        if (readable.push(result)) {\n          return readNext();\n        }\n\n        reading = false;\n      }\n    });\n  }\n\n  return readable;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}