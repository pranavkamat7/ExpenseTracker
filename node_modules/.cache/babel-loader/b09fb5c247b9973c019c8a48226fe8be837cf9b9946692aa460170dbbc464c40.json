{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = exports.ChangeStream = void 0;\nconst Denque = require(\"denque\");\nconst error_1 = require(\"./error\");\nconst aggregate_1 = require(\"./operations/aggregate\");\nconst utils_1 = require(\"./utils\");\nconst mongo_client_1 = require(\"./mongo_client\");\nconst db_1 = require(\"./db\");\nconst collection_1 = require(\"./collection\");\nconst abstract_cursor_1 = require(\"./cursor/abstract_cursor\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst mongo_types_1 = require(\"./mongo_types\");\n/** @internal */\nconst kResumeQueue = Symbol('resumeQueue');\n/** @internal */\nconst kCursorStream = Symbol('cursorStream');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kMode = Symbol('mode');\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(CHANGE_STREAM_OPTIONS);\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\nconst NO_RESUME_TOKEN_ERROR = 'A change stream document has been received that lacks a resume token (_id).';\nconst NO_CURSOR_ERROR = 'ChangeStream has no cursor';\nconst CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @public\n */\nclass ChangeStream extends mongo_types_1.TypedEventEmitter {\n  /**\n   * @internal\n   *\n   * @param parent - The parent object that created this change stream\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n   */\n  constructor(parent, pipeline = [], options = {}) {\n    super();\n    this.pipeline = pipeline;\n    this.options = options;\n    if (parent instanceof collection_1.Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n    } else if (parent instanceof db_1.Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n    } else if (parent instanceof mongo_client_1.MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n    } else {\n      throw new error_1.MongoDriverError('parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient');\n    }\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n    if (!this.options.readPreference && parent.readPreference) {\n      this.options.readPreference = parent.readPreference;\n    }\n    this[kResumeQueue] = new Denque();\n    // Create contained Change Stream cursor\n    this.cursor = createChangeStreamCursor(this, options);\n    this[kClosed] = false;\n    this[kMode] = false;\n    // Listen for any `change` listeners being added to ChangeStream\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        streamEvents(this, this.cursor);\n      }\n    });\n    this.on('removeListener', eventName => {\n      var _a;\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        (_a = this[kCursorStream]) === null || _a === void 0 ? void 0 : _a.removeAllListeners('data');\n      }\n    });\n  }\n  /** @internal */\n  get cursorStream() {\n    return this[kCursorStream];\n  }\n  /** The cached resume token that is used to resume after the most recently returned change. */\n  get resumeToken() {\n    var _a;\n    return (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.resumeToken;\n  }\n  /** Check if there is any document still available in the Change Stream */\n  hasNext(callback) {\n    setIsIterator(this);\n    return utils_1.maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.hasNext(cb);\n      });\n    });\n  }\n  next(callback) {\n    setIsIterator(this);\n    return utils_1.maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.next((error, change) => {\n          if (error) {\n            this[kResumeQueue].push(() => this.next(cb));\n            processError(this, error, cb);\n            return;\n          }\n          processNewChange(this, change, cb);\n        });\n      });\n    });\n  }\n  /** Is the cursor closed */\n  get closed() {\n    var _a, _b;\n    return this[kClosed] || ((_b = (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.closed) !== null && _b !== void 0 ? _b : false);\n  }\n  /** Close the Change Stream */\n  close(callback) {\n    this[kClosed] = true;\n    return utils_1.maybePromise(callback, cb => {\n      if (!this.cursor) {\n        return cb();\n      }\n      const cursor = this.cursor;\n      return cursor.close(err => {\n        endStream(this);\n        this.cursor = undefined;\n        return cb(err);\n      });\n    });\n  }\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @throws MongoDriverError if this.cursor is undefined\n   */\n  stream(options) {\n    this.streamOptions = options;\n    if (!this.cursor) throw new error_1.MongoDriverError(NO_CURSOR_ERROR);\n    return this.cursor.stream(options);\n  }\n  tryNext(callback) {\n    setIsIterator(this);\n    return utils_1.maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        return cursor.tryNext(cb);\n      });\n    });\n  }\n}\nexports.ChangeStream = ChangeStream;\n/** @event */\nChangeStream.RESPONSE = 'response';\n/** @event */\nChangeStream.MORE = 'more';\n/** @event */\nChangeStream.INIT = 'init';\n/** @event */\nChangeStream.CLOSE = 'close';\n/**\n * Fired for each new matching change in the specified namespace. Attaching a `change`\n * event listener to a Change Stream will switch the stream into flowing mode. Data will\n * then be passed as soon as it is available.\n * @event\n */\nChangeStream.CHANGE = 'change';\n/** @event */\nChangeStream.END = 'end';\n/** @event */\nChangeStream.ERROR = 'error';\n/**\n * Emitted each time the change stream stores a new resume token.\n * @event\n */\nChangeStream.RESUME_TOKEN_CHANGED = 'resumeTokenChanged';\n/** @internal */\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(topology, namespace, pipeline = [], options = {}) {\n    super(topology, namespace, options);\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n  get resumeToken() {\n    return this._resumeToken;\n  }\n  get resumeOptions() {\n    const result = {};\n    for (const optionName of CURSOR_OPTIONS) {\n      if (Reflect.has(this.options, optionName)) {\n        Reflect.set(result, optionName, Reflect.get(this.options, optionName));\n      }\n    }\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => Reflect.deleteProperty(result, key));\n      if (this.resumeToken) {\n        const resumeKey = this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\n        Reflect.set(result, resumeKey, this.resumeToken);\n      } else if (this.startAtOperationTime && utils_1.maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n    return result;\n  }\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n  _processBatch(batchName, response) {\n    const cursor = (response === null || response === void 0 ? void 0 : response.cursor) || {};\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = cursor.postBatchResumeToken;\n      if (cursor[batchName].length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n  clone() {\n    return new ChangeStreamCursor(this.topology, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n  _initialize(session, callback) {\n    const aggregateOperation = new aggregate_1.AggregateOperation({\n      s: {\n        namespace: this.namespace\n      }\n    }, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    execute_operation_1.executeOperation(this.topology, aggregateOperation, (err, response) => {\n      if (err || response == null) {\n        return callback(err);\n      }\n      const server = aggregateOperation.server;\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && utils_1.maxWireVersion(server) >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n      this._processBatch('firstBatch', response);\n      this.emit(ChangeStream.INIT, response);\n      this.emit(ChangeStream.RESPONSE);\n      // TODO: NODE-2882\n      callback(undefined, {\n        server,\n        session,\n        response\n      });\n    });\n  }\n  _getMore(batchSize, callback) {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n      this._processBatch('nextBatch', response);\n      this.emit(ChangeStream.MORE, response);\n      this.emit(ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n}\nexports.ChangeStreamCursor = ChangeStreamCursor;\nconst CHANGE_STREAM_EVENTS = [ChangeStream.RESUME_TOKEN_CHANGED, ChangeStream.END, ChangeStream.CLOSE];\nfunction setIsEmitter(changeStream) {\n  if (changeStream[kMode] === 'iterator') {\n    throw new error_1.MongoDriverError('Cannot use ChangeStream as an EventEmitter after using as an iterator');\n  }\n  changeStream[kMode] = 'emitter';\n}\nfunction setIsIterator(changeStream) {\n  if (changeStream[kMode] === 'emitter') {\n    throw new error_1.MongoDriverError('Cannot use ChangeStream as iterator after using as an EventEmitter');\n  }\n  changeStream[kMode] = 'iterator';\n}\n/**\n * Create a new change stream cursor based on self's configuration\n * @internal\n */\nfunction createChangeStreamCursor(changeStream, options) {\n  const changeStreamStageOptions = {\n    fullDocument: options.fullDocument || 'default'\n  };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n  if (changeStream.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n  const pipeline = [{\n    $changeStream: changeStreamStageOptions\n  }].concat(changeStream.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(utils_1.getTopology(changeStream.parent), changeStream.namespace, pipeline, cursorOptions);\n  for (const event of CHANGE_STREAM_EVENTS) {\n    changeStreamCursor.on(event, e => changeStream.emit(event, e));\n  }\n  if (changeStream.listenerCount(ChangeStream.CHANGE) > 0) {\n    streamEvents(changeStream, changeStreamCursor);\n  }\n  return changeStreamCursor;\n}\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n  return target;\n}\n// This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\nconst SELECTION_TIMEOUT = 30000;\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) {\n      options.start = utils_1.now();\n    }\n    const start = options.start || utils_1.now();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    if (topology.isConnected()) {\n      return callback();\n    }\n    if (utils_1.calculateDurationInMs(start) > timeout) {\n      return callback(new error_1.MongoDriverError('Timed out waiting for connection'));\n    }\n    waitForTopologyConnected(topology, options, callback);\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\n}\n\nfunction closeWithError(changeStream, error, callback) {\n  if (!callback) {\n    changeStream.emit(ChangeStream.ERROR, error);\n  }\n  changeStream.close(() => callback && callback(error));\n}\nfunction streamEvents(changeStream, cursor) {\n  setIsEmitter(changeStream);\n  const stream = changeStream[kCursorStream] || cursor.stream();\n  changeStream[kCursorStream] = stream;\n  stream.on('data', change => processNewChange(changeStream, change));\n  stream.on('error', error => processError(changeStream, error));\n}\nfunction endStream(changeStream) {\n  const cursorStream = changeStream[kCursorStream];\n  if (cursorStream) {\n    ['data', 'close', 'end', 'error'].forEach(event => cursorStream.removeAllListeners(event));\n    cursorStream.destroy();\n  }\n  changeStream[kCursorStream] = undefined;\n}\nfunction processNewChange(changeStream, change, callback) {\n  var _a;\n  if (changeStream[kClosed]) {\n    if (callback) callback(new error_1.MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n  // a null change means the cursor has been notified, implicitly closing the change stream\n  if (change == null) {\n    return closeWithError(changeStream, new error_1.MongoDriverError(CHANGESTREAM_CLOSED_ERROR), callback);\n  }\n  if (change && !change._id) {\n    return closeWithError(changeStream, new error_1.MongoDriverError(NO_RESUME_TOKEN_ERROR), callback);\n  }\n  // cache the resume token\n  (_a = changeStream.cursor) === null || _a === void 0 ? void 0 : _a.cacheResumeToken(change._id);\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n  changeStream.options.startAtOperationTime = undefined;\n  // Return the change\n  if (!callback) return changeStream.emit(ChangeStream.CHANGE, change);\n  return callback(undefined, change);\n}\nfunction processError(changeStream, error, callback) {\n  const cursor = changeStream.cursor;\n  // If the change stream has been closed explicitly, do not process error.\n  if (changeStream[kClosed]) {\n    if (callback) callback(new error_1.MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n  // if the resume succeeds, continue with the new cursor\n  function resumeWithCursor(newCursor) {\n    changeStream.cursor = newCursor;\n    processResumeQueue(changeStream);\n  }\n  // otherwise, raise an error and close the change stream\n  function unresumableError(err) {\n    if (!callback) {\n      changeStream.emit(ChangeStream.ERROR, err);\n    }\n    changeStream.close(() => processResumeQueue(changeStream, err));\n  }\n  if (cursor && error_1.isResumableError(error, utils_1.maxWireVersion(cursor.server))) {\n    changeStream.cursor = undefined;\n    // stop listening to all events from old cursor\n    endStream(changeStream);\n    // close internal cursor, ignore errors\n    cursor.close();\n    const topology = utils_1.getTopology(changeStream.parent);\n    waitForTopologyConnected(topology, {\n      readPreference: cursor.readPreference\n    }, err => {\n      // if the topology can't reconnect, close the stream\n      if (err) return unresumableError(err);\n      // create a new cursor, preserving the old cursor's options\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n      // attempt to continue in emitter mode\n      if (!callback) return resumeWithCursor(newCursor);\n      // attempt to continue in iterator mode\n      newCursor.hasNext(err => {\n        // if there's an error immediately after resuming, close the stream\n        if (err) return unresumableError(err);\n        resumeWithCursor(newCursor);\n      });\n    });\n    return;\n  }\n  // if initial error wasn't resumable, raise an error and close the change stream\n  return closeWithError(changeStream, error, callback);\n}\n/**\n * Safely provides a cursor across resume attempts\n *\n * @param changeStream - the parent ChangeStream\n */\nfunction getCursor(changeStream, callback) {\n  if (changeStream[kClosed]) {\n    callback(new error_1.MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n  // if a cursor exists and it is open, return it\n  if (changeStream.cursor) {\n    callback(undefined, changeStream.cursor);\n    return;\n  }\n  // no cursor, queue callback until topology reconnects\n  changeStream[kResumeQueue].push(callback);\n}\n/**\n * Drain the resume queue when a new has become available\n *\n * @param changeStream - the parent ChangeStream\n * @param err - error getting a new cursor\n */\nfunction processResumeQueue(changeStream, err) {\n  while (changeStream[kResumeQueue].length) {\n    const request = changeStream[kResumeQueue].pop();\n    if (!err) {\n      if (changeStream[kClosed]) {\n        request(new error_1.MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n        return;\n      }\n      if (!changeStream.cursor) {\n        request(new error_1.MongoDriverError(NO_CURSOR_ERROR));\n        return;\n      }\n    }\n    request(err, changeStream.cursor);\n  }\n}","map":{"version":3,"names":["Denque","require","error_1","aggregate_1","utils_1","mongo_client_1","db_1","collection_1","abstract_cursor_1","execute_operation_1","mongo_types_1","kResumeQueue","Symbol","kCursorStream","kClosed","kMode","CHANGE_STREAM_OPTIONS","CURSOR_OPTIONS","concat","CHANGE_DOMAIN_TYPES","COLLECTION","DATABASE","CLUSTER","NO_RESUME_TOKEN_ERROR","NO_CURSOR_ERROR","CHANGESTREAM_CLOSED_ERROR","ChangeStream","TypedEventEmitter","constructor","parent","pipeline","options","Collection","type","Db","MongoClient","MongoDriverError","namespace","s","readPreference","cursor","createChangeStreamCursor","on","eventName","listenerCount","streamEvents","_a","removeAllListeners","cursorStream","resumeToken","hasNext","callback","setIsIterator","maybePromise","cb","getCursor","err","next","error","change","push","processError","processNewChange","closed","_b","close","endStream","undefined","stream","streamOptions","tryNext","exports","RESPONSE","MORE","INIT","CLOSE","CHANGE","END","ERROR","RESUME_TOKEN_CHANGED","ChangeStreamCursor","AbstractCursor","topology","_resumeToken","startAtOperationTime","startAfter","resumeAfter","token","emit","resumeOptions","result","optionName","Reflect","has","set","get","forEach","key","deleteProperty","resumeKey","hasReceived","maxWireVersion","server","cacheResumeToken","bufferedCount","postBatchResumeToken","_processBatch","batchName","response","length","clone","cursorOptions","_initialize","session","aggregateOperation","AggregateOperation","executeOperation","operationTime","_getMore","batchSize","CHANGE_STREAM_EVENTS","setIsEmitter","changeStream","changeStreamStageOptions","fullDocument","applyKnownOptions","allChangesForCluster","$changeStream","changeStreamCursor","getTopology","event","e","target","source","optionNames","name","SELECTION_TIMEOUT","waitForTopologyConnected","setTimeout","start","now","timeout","isConnected","calculateDurationInMs","closeWithError","destroy","_id","resumeWithCursor","newCursor","processResumeQueue","unresumableError","isResumableError","request","pop"],"sources":["C:\\Users\\pranav kamat\\node_modules\\mongodb\\src\\change_stream.ts"],"sourcesContent":["import Denque = require('denque');\nimport { MongoError, AnyError, isResumableError, MongoDriverError } from './error';\nimport { AggregateOperation, AggregateOptions } from './operations/aggregate';\nimport {\n  maxWireVersion,\n  calculateDurationInMs,\n  now,\n  maybePromise,\n  MongoDBNamespace,\n  Callback,\n  getTopology\n} from './utils';\nimport type { ReadPreference } from './read_preference';\nimport type { Timestamp, Document } from './bson';\nimport type { Topology } from './sdam/topology';\nimport type { OperationParent, CollationOptions } from './operations/command';\nimport { MongoClient } from './mongo_client';\nimport { Db } from './db';\nimport { Collection } from './collection';\nimport type { Readable } from 'stream';\nimport {\n  AbstractCursor,\n  AbstractCursorEvents,\n  AbstractCursorOptions,\n  CursorStreamOptions\n} from './cursor/abstract_cursor';\nimport type { ClientSession } from './sessions';\nimport { executeOperation, ExecutionResult } from './operations/execute_operation';\nimport { InferIdType, Nullable, TypedEventEmitter } from './mongo_types';\n\n/** @internal */\nconst kResumeQueue = Symbol('resumeQueue');\n/** @internal */\nconst kCursorStream = Symbol('cursorStream');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kMode = Symbol('mode');\n\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(\n  CHANGE_STREAM_OPTIONS\n);\n\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n\nconst NO_RESUME_TOKEN_ERROR =\n  'A change stream document has been received that lacks a resume token (_id).';\nconst NO_CURSOR_ERROR = 'ChangeStream has no cursor';\nconst CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';\n\n/** @public */\nexport interface ResumeOptions {\n  startAtOperationTime?: Timestamp;\n  batchSize?: number;\n  maxAwaitTimeMS?: number;\n  collation?: CollationOptions;\n  readPreference?: ReadPreference;\n}\n\n/**\n * Represents the logical starting point for a new or resuming {@link https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token| Change Stream} on the server.\n * @public\n */\nexport type ResumeToken = unknown;\n\n/**\n * Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @public\n * @remarks\n * See {@link https://docs.mongodb.com/manual/reference/method/db.runCommand/#response| Run Command Response}\n */\nexport type OperationTime = Timestamp;\n\n/** @public */\nexport interface PipeOptions {\n  end?: boolean;\n}\n\n/**\n * Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @public\n */\nexport interface ChangeStreamOptions extends AggregateOptions {\n  /** Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred. */\n  fullDocument?: string;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a change stream query. */\n  maxAwaitTimeMS?: number;\n  /** Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}. */\n  resumeAfter?: ResumeToken;\n  /** Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}. */\n  startAfter?: ResumeToken;\n  /** Will start the changeStream after the specified operationTime. */\n  startAtOperationTime?: OperationTime;\n  /** The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}. */\n  batchSize?: number;\n}\n\n/** @public */\nexport interface ChangeStreamDocument<TSchema extends Document = Document> {\n  /**\n   * The id functions as an opaque token for use when resuming an interrupted\n   * change stream.\n   */\n  _id: InferIdType<TSchema>;\n\n  /**\n   * Describes the type of operation represented in this change notification.\n   */\n  operationType:\n    | 'insert'\n    | 'update'\n    | 'replace'\n    | 'delete'\n    | 'invalidate'\n    | 'drop'\n    | 'dropDatabase'\n    | 'rename';\n\n  /**\n   * Contains two fields: “db” and “coll” containing the database and\n   * collection name in which the change happened.\n   */\n  ns: { db: string; coll: string };\n\n  /**\n   * Only present for ops of type ‘insert’, ‘update’, ‘replace’, and\n   * ‘delete’.\n   *\n   * For unsharded collections this contains a single field, _id, with the\n   * value of the _id of the document updated.  For sharded collections,\n   * this will contain all the components of the shard key in order,\n   * followed by the _id if the _id isn’t part of the shard key.\n   */\n  documentKey?: InferIdType<TSchema>;\n\n  /**\n   * Only present for ops of type ‘update’.\n   *\n   * Contains a description of updated and removed fields in this\n   * operation.\n   */\n  updateDescription?: UpdateDescription<TSchema>;\n\n  /**\n   * Always present for operations of type ‘insert’ and ‘replace’. Also\n   * present for operations of type ‘update’ if the user has specified ‘updateLookup’\n   * in the ‘fullDocument’ arguments to the ‘$changeStream’ stage.\n   *\n   * For operations of type ‘insert’ and ‘replace’, this key will contain the\n   * document being inserted, or the new version of the document that is replacing\n   * the existing document, respectively.\n   *\n   * For operations of type ‘update’, this key will contain a copy of the full\n   * version of the document from some point after the update occurred. If the\n   * document was deleted since the updated happened, it will be null.\n   */\n  fullDocument?: TSchema;\n}\n\n/** @public */\nexport interface UpdateDescription<TSchema extends Document = Document> {\n  /**\n   * A document containing key:value pairs of names of the fields that were\n   * changed, and the new value for those fields.\n   */\n  updatedFields: Partial<TSchema>;\n\n  /**\n   * An array of field names that were removed from the document.\n   */\n  removedFields: string[];\n}\n\n/** @public */\nexport type ChangeStreamEvents = {\n  resumeTokenChanged(token: ResumeToken): void;\n  init(response: Document): void;\n  more(response?: Document | undefined): void;\n  response(): void;\n  end(): void;\n  error(error: Error): void;\n  change(change: ChangeStreamDocument): void;\n} & AbstractCursorEvents;\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @public\n */\nexport class ChangeStream<TSchema extends Document = Document> extends TypedEventEmitter<\n  ChangeStreamEvents\n> {\n  pipeline: Document[];\n  options: ChangeStreamOptions;\n  parent: MongoClient | Db | Collection;\n  namespace: MongoDBNamespace;\n  type: symbol;\n  /** @internal */\n  cursor?: ChangeStreamCursor<TSchema>;\n  streamOptions?: CursorStreamOptions;\n  /** @internal */\n  [kResumeQueue]: Denque;\n  /** @internal */\n  [kCursorStream]?: Readable;\n  /** @internal */\n  [kClosed]: boolean;\n  /** @internal */\n  [kMode]: false | 'iterator' | 'emitter';\n\n  /** @event */\n  static readonly RESPONSE = 'response' as const;\n  /** @event */\n  static readonly MORE = 'more' as const;\n  /** @event */\n  static readonly INIT = 'init' as const;\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   * @event\n   */\n  static readonly CHANGE = 'change' as const;\n  /** @event */\n  static readonly END = 'end' as const;\n  /** @event */\n  static readonly ERROR = 'error' as const;\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   * @event\n   */\n  static readonly RESUME_TOKEN_CHANGED = 'resumeTokenChanged' as const;\n\n  /**\n   * @internal\n   *\n   * @param parent - The parent object that created this change stream\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n   */\n  constructor(\n    parent: OperationParent,\n    pipeline: Document[] = [],\n    options: ChangeStreamOptions = {}\n  ) {\n    super();\n\n    this.pipeline = pipeline;\n    this.options = options;\n\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n    } else {\n      throw new MongoDriverError(\n        'parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient'\n      );\n    }\n\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n    if (!this.options.readPreference && parent.readPreference) {\n      this.options.readPreference = parent.readPreference;\n    }\n\n    this[kResumeQueue] = new Denque();\n\n    // Create contained Change Stream cursor\n    this.cursor = createChangeStreamCursor(this, options);\n\n    this[kClosed] = false;\n    this[kMode] = false;\n\n    // Listen for any `change` listeners being added to ChangeStream\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        streamEvents(this, this.cursor);\n      }\n    });\n\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this[kCursorStream]?.removeAllListeners('data');\n      }\n    });\n  }\n\n  /** @internal */\n  get cursorStream(): Readable | undefined {\n    return this[kCursorStream];\n  }\n\n  /** The cached resume token that is used to resume after the most recently returned change. */\n  get resumeToken(): ResumeToken {\n    return this.cursor?.resumeToken;\n  }\n\n  /** Check if there is any document still available in the Change Stream */\n  hasNext(callback?: Callback): Promise<void> | void {\n    setIsIterator(this);\n    return maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.hasNext(cb);\n      });\n    });\n  }\n\n  /** Get the next available document from the Change Stream. */\n  next(): Promise<ChangeStreamDocument<TSchema>>;\n  next(callback: Callback<ChangeStreamDocument<TSchema>>): void;\n  next(\n    callback?: Callback<ChangeStreamDocument<TSchema>>\n  ): Promise<ChangeStreamDocument<TSchema>> | void {\n    setIsIterator(this);\n    return maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        cursor.next((error, change) => {\n          if (error) {\n            this[kResumeQueue].push(() => this.next(cb));\n            processError(this, error, cb);\n            return;\n          }\n          processNewChange<TSchema>(this, change, cb);\n        });\n      });\n    });\n  }\n\n  /** Is the cursor closed */\n  get closed(): boolean {\n    return this[kClosed] || (this.cursor?.closed ?? false);\n  }\n\n  /** Close the Change Stream */\n  close(callback?: Callback): Promise<void> | void {\n    this[kClosed] = true;\n\n    return maybePromise(callback, cb => {\n      if (!this.cursor) {\n        return cb();\n      }\n\n      const cursor = this.cursor;\n      return cursor.close(err => {\n        endStream(this);\n        this.cursor = undefined;\n        return cb(err);\n      });\n    });\n  }\n\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @throws MongoDriverError if this.cursor is undefined\n   */\n  stream(options?: CursorStreamOptions): Readable {\n    this.streamOptions = options;\n    if (!this.cursor) throw new MongoDriverError(NO_CURSOR_ERROR);\n    return this.cursor.stream(options);\n  }\n\n  /**\n   * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned\n   */\n  tryNext(): Promise<Document | null>;\n  tryNext(callback: Callback<Document | null>): void;\n  tryNext(callback?: Callback<Document | null>): Promise<Document | null> | void {\n    setIsIterator(this);\n    return maybePromise(callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err || !cursor) return cb(err); // failed to resume, raise an error\n        return cursor.tryNext(cb);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport interface ChangeStreamCursorOptions extends AbstractCursorOptions {\n  startAtOperationTime?: OperationTime;\n  resumeAfter?: ResumeToken;\n  startAfter?: boolean;\n}\n\n/** @internal */\nexport class ChangeStreamCursor<TSchema extends Document = Document> extends AbstractCursor<\n  ChangeStreamDocument<TSchema>,\n  ChangeStreamEvents\n> {\n  _resumeToken: ResumeToken;\n  startAtOperationTime?: OperationTime;\n  hasReceived?: boolean;\n  resumeAfter: ResumeToken;\n  startAfter: ResumeToken;\n  options: ChangeStreamCursorOptions;\n\n  postBatchResumeToken?: ResumeToken;\n  pipeline: Document[];\n\n  constructor(\n    topology: Topology,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: ChangeStreamCursorOptions = {}\n  ) {\n    super(topology, namespace, options);\n\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token: ResumeToken) {\n    this._resumeToken = token;\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n\n  get resumeToken(): ResumeToken {\n    return this._resumeToken;\n  }\n\n  get resumeOptions(): ResumeOptions {\n    const result = {} as ResumeOptions;\n    for (const optionName of CURSOR_OPTIONS) {\n      if (Reflect.has(this.options, optionName)) {\n        Reflect.set(result, optionName, Reflect.get(this.options, optionName));\n      }\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key =>\n        Reflect.deleteProperty(result, key)\n      );\n\n      if (this.resumeToken) {\n        const resumeKey =\n          this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\n        Reflect.set(result, resumeKey, this.resumeToken);\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  cacheResumeToken(resumeToken: ResumeToken): void {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n\n  _processBatch(batchName: string, response?: Document): void {\n    const cursor = response?.cursor || {};\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = cursor.postBatchResumeToken;\n\n      if (cursor[batchName].length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  clone(): AbstractCursor<ChangeStreamDocument<TSchema>> {\n    return new ChangeStreamCursor(this.topology, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n\n  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {\n    const aggregateOperation = new AggregateOperation(\n      { s: { namespace: this.namespace } },\n      this.pipeline,\n      {\n        ...this.cursorOptions,\n        ...this.options,\n        session\n      }\n    );\n\n    executeOperation(this.topology, aggregateOperation, (err, response) => {\n      if (err || response == null) {\n        return callback(err);\n      }\n\n      const server = aggregateOperation.server;\n      if (\n        this.startAtOperationTime == null &&\n        this.resumeAfter == null &&\n        this.startAfter == null &&\n        maxWireVersion(server) >= 7\n      ) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      this._processBatch('firstBatch', response);\n\n      this.emit(ChangeStream.INIT, response);\n      this.emit(ChangeStream.RESPONSE);\n\n      // TODO: NODE-2882\n      callback(undefined, { server, session, response });\n    });\n  }\n\n  _getMore(batchSize: number, callback: Callback): void {\n    super._getMore(batchSize, (err, response) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this._processBatch('nextBatch', response);\n\n      this.emit(ChangeStream.MORE, response);\n      this.emit(ChangeStream.RESPONSE);\n      callback(err, response);\n    });\n  }\n}\n\nconst CHANGE_STREAM_EVENTS = [\n  ChangeStream.RESUME_TOKEN_CHANGED,\n  ChangeStream.END,\n  ChangeStream.CLOSE\n];\n\nfunction setIsEmitter<TSchema>(changeStream: ChangeStream<TSchema>): void {\n  if (changeStream[kMode] === 'iterator') {\n    throw new MongoDriverError(\n      'Cannot use ChangeStream as an EventEmitter after using as an iterator'\n    );\n  }\n  changeStream[kMode] = 'emitter';\n}\n\nfunction setIsIterator<TSchema>(changeStream: ChangeStream<TSchema>): void {\n  if (changeStream[kMode] === 'emitter') {\n    throw new MongoDriverError(\n      'Cannot use ChangeStream as iterator after using as an EventEmitter'\n    );\n  }\n  changeStream[kMode] = 'iterator';\n}\n/**\n * Create a new change stream cursor based on self's configuration\n * @internal\n */\nfunction createChangeStreamCursor<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  options: ChangeStreamOptions\n): ChangeStreamCursor<TSchema> {\n  const changeStreamStageOptions: Document = { fullDocument: options.fullDocument || 'default' };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n  if (changeStream.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{ $changeStream: changeStreamStageOptions } as Document].concat(\n    changeStream.pipeline\n  );\n\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor<TSchema>(\n    getTopology(changeStream.parent),\n    changeStream.namespace,\n    pipeline,\n    cursorOptions\n  );\n\n  for (const event of CHANGE_STREAM_EVENTS) {\n    changeStreamCursor.on(event, e => changeStream.emit(event, e));\n  }\n\n  if (changeStream.listenerCount(ChangeStream.CHANGE) > 0) {\n    streamEvents(changeStream, changeStreamCursor);\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target: Document, source: Document, optionNames: string[]) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n\n  return target;\n}\n\ninterface TopologyWaitOptions {\n  start?: number;\n  timeout?: number;\n  readPreference?: ReadPreference;\n}\n// This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\nconst SELECTION_TIMEOUT = 30000;\nfunction waitForTopologyConnected(\n  topology: Topology,\n  options: TopologyWaitOptions,\n  callback: Callback\n) {\n  setTimeout(() => {\n    if (options && options.start == null) {\n      options.start = now();\n    }\n\n    const start = options.start || now();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    if (topology.isConnected()) {\n      return callback();\n    }\n\n    if (calculateDurationInMs(start) > timeout) {\n      return callback(new MongoDriverError('Timed out waiting for connection'));\n    }\n\n    waitForTopologyConnected(topology, options, callback);\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\n}\n\nfunction closeWithError<T>(\n  changeStream: ChangeStream<T>,\n  error: AnyError,\n  callback?: Callback\n): void {\n  if (!callback) {\n    changeStream.emit(ChangeStream.ERROR, error);\n  }\n\n  changeStream.close(() => callback && callback(error));\n}\n\nfunction streamEvents<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  cursor: ChangeStreamCursor<TSchema>\n): void {\n  setIsEmitter(changeStream);\n  const stream = changeStream[kCursorStream] || cursor.stream();\n  changeStream[kCursorStream] = stream;\n  stream.on('data', change => processNewChange(changeStream, change));\n  stream.on('error', error => processError(changeStream, error));\n}\n\nfunction endStream<TSchema>(changeStream: ChangeStream<TSchema>): void {\n  const cursorStream = changeStream[kCursorStream];\n  if (cursorStream) {\n    ['data', 'close', 'end', 'error'].forEach(event => cursorStream.removeAllListeners(event));\n    cursorStream.destroy();\n  }\n\n  changeStream[kCursorStream] = undefined;\n}\n\nfunction processNewChange<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  change: Nullable<ChangeStreamDocument<TSchema>>,\n  callback?: Callback<ChangeStreamDocument<TSchema>>\n) {\n  if (changeStream[kClosed]) {\n    if (callback) callback(new MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n\n  // a null change means the cursor has been notified, implicitly closing the change stream\n  if (change == null) {\n    return closeWithError(changeStream, new MongoDriverError(CHANGESTREAM_CLOSED_ERROR), callback);\n  }\n\n  if (change && !change._id) {\n    return closeWithError(changeStream, new MongoDriverError(NO_RESUME_TOKEN_ERROR), callback);\n  }\n\n  // cache the resume token\n  changeStream.cursor?.cacheResumeToken(change._id);\n\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n  changeStream.options.startAtOperationTime = undefined;\n\n  // Return the change\n  if (!callback) return changeStream.emit(ChangeStream.CHANGE, change);\n  return callback(undefined, change);\n}\n\nfunction processError<TSchema>(\n  changeStream: ChangeStream<TSchema>,\n  error: AnyError,\n  callback?: Callback\n) {\n  const cursor = changeStream.cursor;\n\n  // If the change stream has been closed explicitly, do not process error.\n  if (changeStream[kClosed]) {\n    if (callback) callback(new MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n\n  // if the resume succeeds, continue with the new cursor\n  function resumeWithCursor(newCursor: ChangeStreamCursor<TSchema>) {\n    changeStream.cursor = newCursor;\n    processResumeQueue(changeStream);\n  }\n\n  // otherwise, raise an error and close the change stream\n  function unresumableError(err: AnyError) {\n    if (!callback) {\n      changeStream.emit(ChangeStream.ERROR, err);\n    }\n\n    changeStream.close(() => processResumeQueue(changeStream, err));\n  }\n\n  if (cursor && isResumableError(error as MongoError, maxWireVersion(cursor.server))) {\n    changeStream.cursor = undefined;\n\n    // stop listening to all events from old cursor\n    endStream(changeStream);\n\n    // close internal cursor, ignore errors\n    cursor.close();\n\n    const topology = getTopology(changeStream.parent);\n    waitForTopologyConnected(topology, { readPreference: cursor.readPreference }, err => {\n      // if the topology can't reconnect, close the stream\n      if (err) return unresumableError(err);\n\n      // create a new cursor, preserving the old cursor's options\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n\n      // attempt to continue in emitter mode\n      if (!callback) return resumeWithCursor(newCursor);\n\n      // attempt to continue in iterator mode\n      newCursor.hasNext(err => {\n        // if there's an error immediately after resuming, close the stream\n        if (err) return unresumableError(err);\n        resumeWithCursor(newCursor);\n      });\n    });\n    return;\n  }\n\n  // if initial error wasn't resumable, raise an error and close the change stream\n  return closeWithError(changeStream, error, callback);\n}\n\n/**\n * Safely provides a cursor across resume attempts\n *\n * @param changeStream - the parent ChangeStream\n */\nfunction getCursor<T>(changeStream: ChangeStream<T>, callback: Callback<ChangeStreamCursor<T>>) {\n  if (changeStream[kClosed]) {\n    callback(new MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n    return;\n  }\n\n  // if a cursor exists and it is open, return it\n  if (changeStream.cursor) {\n    callback(undefined, changeStream.cursor);\n    return;\n  }\n\n  // no cursor, queue callback until topology reconnects\n  changeStream[kResumeQueue].push(callback);\n}\n\n/**\n * Drain the resume queue when a new has become available\n *\n * @param changeStream - the parent ChangeStream\n * @param err - error getting a new cursor\n */\nfunction processResumeQueue<TSchema>(changeStream: ChangeStream<TSchema>, err?: Error) {\n  while (changeStream[kResumeQueue].length) {\n    const request = changeStream[kResumeQueue].pop();\n    if (!err) {\n      if (changeStream[kClosed]) {\n        request(new MongoDriverError(CHANGESTREAM_CLOSED_ERROR));\n        return;\n      }\n      if (!changeStream.cursor) {\n        request(new MongoDriverError(NO_CURSOR_ERROR));\n        return;\n      }\n    }\n    request(err, changeStream.cursor);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}